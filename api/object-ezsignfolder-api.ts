/* tslint:disable */
/* eslint-disable */
/**
 * eZmax API Definition (Full)
 * This API expose all the functionnalities for the eZmax and eZsign applications.
 *
 * The version of the OpenAPI document: 1.2.1
 * Contact: support-api@ezmax.ca
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CommonResponse } from '../model';
// @ts-ignore
import type { CommonResponseError } from '../model';
// @ts-ignore
import type { EzsignfolderBatchDownloadV1Request } from '../model';
// @ts-ignore
import type { EzsignfolderCreateObjectV1Request } from '../model';
// @ts-ignore
import type { EzsignfolderCreateObjectV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderCreateObjectV2Request } from '../model';
// @ts-ignore
import type { EzsignfolderCreateObjectV2Response } from '../model';
// @ts-ignore
import type { EzsignfolderCreateObjectV3Request } from '../model';
// @ts-ignore
import type { EzsignfolderCreateObjectV3Response } from '../model';
// @ts-ignore
import type { EzsignfolderDisposeEzsignfoldersV1Request } from '../model';
// @ts-ignore
import type { EzsignfolderEditObjectV3Request } from '../model';
// @ts-ignore
import type { EzsignfolderGetActionableElementsV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetAttachmentCountV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetAttachmentsV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetCommunicationCountV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetCommunicationListV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetCommunicationrecipientsV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetCommunicationsendersV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetEzsigndocumentsV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetEzsignfoldersignerassociationsV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetEzsignsignaturesAutomaticV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetFormsDataV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetListV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetObjectV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetObjectV2Response } from '../model';
// @ts-ignore
import type { EzsignfolderGetObjectV3Response } from '../model';
// @ts-ignore
import type { EzsignfolderImportEzsignfoldersignerassociationsV1Request } from '../model';
// @ts-ignore
import type { EzsignfolderImportEzsignfoldersignerassociationsV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderImportEzsigntemplatepackageV1Request } from '../model';
// @ts-ignore
import type { EzsignfolderImportEzsigntemplatepackageV1Response } from '../model';
// @ts-ignore
import type { EzsignfolderReorderV1Request } from '../model';
// @ts-ignore
import type { EzsignfolderReorderV2Request } from '../model';
// @ts-ignore
import type { EzsignfolderSendV1Request } from '../model';
// @ts-ignore
import type { EzsignfolderSendV3Request } from '../model';
// @ts-ignore
import type { HeaderAcceptLanguage } from '../model';
// @ts-ignore
import { RequestSignature, IHeadersData } from '../api/request-signature';
/**
 * ObjectEzsignfolderApi - axios parameter creator
 * @export
 */
export const ObjectEzsignfolderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderArchiveV1: async (pkiEzsignfolderID: number, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderArchiveV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ezsignfolderArchiveV1', 'body', body)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/archive`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download multiples files from an Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderBatchDownloadV1Request} ezsignfolderBatchDownloadV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderBatchDownloadV1: async (pkiEzsignfolderID: number, ezsignfolderBatchDownloadV1Request: EzsignfolderBatchDownloadV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderBatchDownloadV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderBatchDownloadV1Request' is not null or undefined
            assertParamExists('ezsignfolderBatchDownloadV1', 'ezsignfolderBatchDownloadV1Request', ezsignfolderBatchDownloadV1Request)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/batchDownload`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderBatchDownloadV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfolder
         * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV1: async (ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ezsignfolderCreateObjectV1Request' is not null or undefined
            assertParamExists('ezsignfolderCreateObjectV1', 'ezsignfolderCreateObjectV1Request', ezsignfolderCreateObjectV1Request)
            const localVarPath = `/1/object/ezsignfolder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderCreateObjectV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new Ezsignfolder
         * @param {EzsignfolderCreateObjectV2Request} ezsignfolderCreateObjectV2Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV2: async (ezsignfolderCreateObjectV2Request: EzsignfolderCreateObjectV2Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ezsignfolderCreateObjectV2Request' is not null or undefined
            assertParamExists('ezsignfolderCreateObjectV2', 'ezsignfolderCreateObjectV2Request', ezsignfolderCreateObjectV2Request)
            const localVarPath = `/2/object/ezsignfolder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderCreateObjectV2Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new Ezsignfolder
         * @param {EzsignfolderCreateObjectV3Request} ezsignfolderCreateObjectV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV3: async (ezsignfolderCreateObjectV3Request: EzsignfolderCreateObjectV3Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ezsignfolderCreateObjectV3Request' is not null or undefined
            assertParamExists('ezsignfolderCreateObjectV3', 'ezsignfolderCreateObjectV3Request', ezsignfolderCreateObjectV3Request)
            const localVarPath = `/3/object/ezsignfolder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderCreateObjectV3Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDeleteObjectV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderDeleteObjectV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'DELETE' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dispose Ezsignfolders
         * @param {EzsignfolderDisposeEzsignfoldersV1Request} ezsignfolderDisposeEzsignfoldersV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDisposeEzsignfoldersV1: async (ezsignfolderDisposeEzsignfoldersV1Request: EzsignfolderDisposeEzsignfoldersV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ezsignfolderDisposeEzsignfoldersV1Request' is not null or undefined
            assertParamExists('ezsignfolderDisposeEzsignfoldersV1', 'ezsignfolderDisposeEzsignfoldersV1Request', ezsignfolderDisposeEzsignfoldersV1Request)
            const localVarPath = `/1/object/ezsignfolder/disposeEzsignfolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderDisposeEzsignfoldersV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dispose the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDisposeV1: async (pkiEzsignfolderID: number, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderDisposeV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ezsignfolderDisposeV1', 'body', body)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/dispose`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderEditObjectV3Request} ezsignfolderEditObjectV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderEditObjectV3: async (pkiEzsignfolderID: number, ezsignfolderEditObjectV3Request: EzsignfolderEditObjectV3Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderEditObjectV3', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderEditObjectV3Request' is not null or undefined
            assertParamExists('ezsignfolderEditObjectV3', 'ezsignfolderEditObjectV3Request', ezsignfolderEditObjectV3Request)
            const localVarPath = `/3/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderEditObjectV3Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'PUT' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End prematurely all Ezsigndocument of Ezsignfolder when some signatures are still required
         * @summary End prematurely
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderEndPrematurelyV1: async (pkiEzsignfolderID: number, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderEndPrematurelyV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ezsignfolderEndPrematurelyV1', 'body', body)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/endPrematurely`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
         * @summary Retrieve actionable elements for the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetActionableElementsV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetActionableElementsV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getActionableElements`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Attachment count
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetAttachmentCountV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetAttachmentCountV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getAttachmentCount`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Ezsignfolder\'s Attachments
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetAttachmentsV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetAttachmentsV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getAttachments`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Communication count
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetCommunicationCountV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetCommunicationCountV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getCommunicationCount`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Communication list
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetCommunicationListV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetCommunicationListV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getCommunicationList`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Ezsignfolder\'s Communicationrecipient
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetCommunicationrecipientsV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetCommunicationrecipientsV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getCommunicationrecipients`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Ezsignfolder\'s Communicationsender
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetCommunicationsendersV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetCommunicationsendersV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getCommunicationsenders`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsigndocuments
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetEzsigndocumentsV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetEzsigndocumentsV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsigndocuments`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsignfoldersignerassociations
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetEzsignfoldersignerassociationsV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetEzsignfoldersignerassociationsV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsignfoldersignerassociations`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the Ezsignsignatures that can be signed by the current user at the current step in the process
         * @summary Retrieve an existing Ezsignfolder\'s automatic Ezsignsignatures
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetEzsignsignaturesAutomaticV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetEzsignsignaturesAutomaticV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsignsignaturesAutomatic`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s forms data
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetFormsDataV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetFormsDataV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getFormsData`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent<br>Sent<br>PartiallySigned<br>Expired<br>Completed<br>Archived<br>Disposed| | eEzsignfoldertypePrivacylevel | User<br>Usergroup |  Advanced filters that can be used in query parameter *sFilter*:  | Variable | |---| | fkiUserID | | sContactFirstname | | sContactLastname | | sUserFirstname | | sUserLastname | | sEzsigndocumentName |
         * @summary Retrieve Ezsignfolder list
         * @param {EzsignfolderGetListV1EOrderByEnum} [eOrderBy] Specify how you want the results to be sorted
         * @param {number} [iRowMax] 
         * @param {number} [iRowOffset] 
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {string} [sFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetListV1: async (eOrderBy?: EzsignfolderGetListV1EOrderByEnum, iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1/object/ezsignfolder/getList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (eOrderBy !== undefined) {
                localVarQueryParameter['eOrderBy'] = eOrderBy;
            }

            if (iRowMax !== undefined) {
                localVarQueryParameter['iRowMax'] = iRowMax;
            }

            if (iRowOffset !== undefined) {
                localVarQueryParameter['iRowOffset'] = iRowOffset;
            }

            if (sFilter !== undefined) {
                localVarQueryParameter['sFilter'] = sFilter;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string'
                    ? acceptLanguage
                    : JSON.stringify(acceptLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV1: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetObjectV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV2: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetObjectV2', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/2/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV3: async (pkiEzsignfolderID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetObjectV3', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/3/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsignfoldersignerassociationsV1Request} ezsignfolderImportEzsignfoldersignerassociationsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderImportEzsignfoldersignerassociationsV1: async (pkiEzsignfolderID: number, ezsignfolderImportEzsignfoldersignerassociationsV1Request: EzsignfolderImportEzsignfoldersignerassociationsV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderImportEzsignfoldersignerassociationsV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderImportEzsignfoldersignerassociationsV1Request' is not null or undefined
            assertParamExists('ezsignfolderImportEzsignfoldersignerassociationsV1', 'ezsignfolderImportEzsignfoldersignerassociationsV1Request', ezsignfolderImportEzsignfoldersignerassociationsV1Request)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/importEzsignfoldersignerassociations`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderImportEzsignfoldersignerassociationsV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
         * @summary Import an Ezsigntemplatepackage in the Ezsignfolder.
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsigntemplatepackageV1Request} ezsignfolderImportEzsigntemplatepackageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderImportEzsigntemplatepackageV1: async (pkiEzsignfolderID: number, ezsignfolderImportEzsigntemplatepackageV1Request: EzsignfolderImportEzsigntemplatepackageV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderImportEzsigntemplatepackageV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderImportEzsigntemplatepackageV1Request' is not null or undefined
            assertParamExists('ezsignfolderImportEzsigntemplatepackageV1', 'ezsignfolderImportEzsigntemplatepackageV1Request', ezsignfolderImportEzsigntemplatepackageV1Request)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/importEzsigntemplatepackage`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderImportEzsigntemplatepackageV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reorder Ezsigndocuments in the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderReorderV1Request} ezsignfolderReorderV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderReorderV1: async (pkiEzsignfolderID: number, ezsignfolderReorderV1Request: EzsignfolderReorderV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderReorderV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderReorderV1Request' is not null or undefined
            assertParamExists('ezsignfolderReorderV1', 'ezsignfolderReorderV1Request', ezsignfolderReorderV1Request)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/reorder`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderReorderV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reorder Ezsigndocuments in the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderReorderV2Request} ezsignfolderReorderV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderReorderV2: async (pkiEzsignfolderID: number, ezsignfolderReorderV2Request: EzsignfolderReorderV2Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderReorderV2', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderReorderV2Request' is not null or undefined
            assertParamExists('ezsignfolderReorderV2', 'ezsignfolderReorderV2Request', ezsignfolderReorderV2Request)
            const localVarPath = `/2/object/ezsignfolder/{pkiEzsignfolderID}/reorder`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderReorderV2Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderSendV1: async (pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderSendV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderSendV1Request' is not null or undefined
            assertParamExists('ezsignfolderSendV1', 'ezsignfolderSendV1Request', ezsignfolderSendV1Request)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/send`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderSendV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV3Request} ezsignfolderSendV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderSendV3: async (pkiEzsignfolderID: number, ezsignfolderSendV3Request: EzsignfolderSendV3Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderSendV3', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderSendV3Request' is not null or undefined
            assertParamExists('ezsignfolderSendV3', 'ezsignfolderSendV3Request', ezsignfolderSendV3Request)
            const localVarPath = `/3/object/ezsignfolder/{pkiEzsignfolderID}/send`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderSendV3Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \"Non-completed\" Ezsigndocuments will be lost.
         * @summary Unsend the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderUnsendV1: async (pkiEzsignfolderID: number, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderUnsendV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ezsignfolderUnsendV1', 'body', body)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/unsend`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectEzsignfolderApi - functional programming interface
 * @export
 */
export const ObjectEzsignfolderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObjectEzsignfolderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Archive the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderArchiveV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderArchiveV1(pkiEzsignfolderID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderArchiveV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download multiples files from an Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderBatchDownloadV1Request} ezsignfolderBatchDownloadV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderBatchDownloadV1(pkiEzsignfolderID: number, ezsignfolderBatchDownloadV1Request: EzsignfolderBatchDownloadV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderBatchDownloadV1(pkiEzsignfolderID, ezsignfolderBatchDownloadV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderBatchDownloadV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfolder
         * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderCreateObjectV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderCreateObjectV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new Ezsignfolder
         * @param {EzsignfolderCreateObjectV2Request} ezsignfolderCreateObjectV2Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request: EzsignfolderCreateObjectV2Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderCreateObjectV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderCreateObjectV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new Ezsignfolder
         * @param {EzsignfolderCreateObjectV3Request} ezsignfolderCreateObjectV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderCreateObjectV3(ezsignfolderCreateObjectV3Request: EzsignfolderCreateObjectV3Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderCreateObjectV3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderCreateObjectV3(ezsignfolderCreateObjectV3Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderCreateObjectV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderDeleteObjectV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderDeleteObjectV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderDeleteObjectV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dispose Ezsignfolders
         * @param {EzsignfolderDisposeEzsignfoldersV1Request} ezsignfolderDisposeEzsignfoldersV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request: EzsignfolderDisposeEzsignfoldersV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderDisposeEzsignfoldersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dispose the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderDisposeV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderDisposeV1(pkiEzsignfolderID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderDisposeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderEditObjectV3Request} ezsignfolderEditObjectV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderEditObjectV3(pkiEzsignfolderID: number, ezsignfolderEditObjectV3Request: EzsignfolderEditObjectV3Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderEditObjectV3(pkiEzsignfolderID, ezsignfolderEditObjectV3Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderEditObjectV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End prematurely all Ezsigndocument of Ezsignfolder when some signatures are still required
         * @summary End prematurely
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderEndPrematurelyV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderEndPrematurelyV1(pkiEzsignfolderID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderEndPrematurelyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
         * @summary Retrieve actionable elements for the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetActionableElementsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetActionableElementsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetActionableElementsV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetActionableElementsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Attachment count
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetAttachmentCountV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetAttachmentCountV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetAttachmentCountV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetAttachmentCountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Ezsignfolder\'s Attachments
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetAttachmentsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetAttachmentsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetAttachmentsV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetAttachmentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Communication count
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetCommunicationCountV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetCommunicationCountV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetCommunicationCountV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetCommunicationCountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Communication list
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetCommunicationListV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetCommunicationListV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetCommunicationListV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetCommunicationListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Ezsignfolder\'s Communicationrecipient
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetCommunicationrecipientsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetCommunicationrecipientsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetCommunicationrecipientsV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetCommunicationrecipientsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Ezsignfolder\'s Communicationsender
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetCommunicationsendersV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetCommunicationsendersV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetCommunicationsendersV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetCommunicationsendersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsigndocuments
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetEzsigndocumentsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetEzsigndocumentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsignfoldersignerassociations
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetEzsignfoldersignerassociationsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetEzsignfoldersignerassociationsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the Ezsignsignatures that can be signed by the current user at the current step in the process
         * @summary Retrieve an existing Ezsignfolder\'s automatic Ezsignsignatures
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetEzsignsignaturesAutomaticV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetEzsignsignaturesAutomaticV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetEzsignsignaturesAutomaticV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetEzsignsignaturesAutomaticV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s forms data
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetFormsDataV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetFormsDataV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetFormsDataV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetFormsDataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent<br>Sent<br>PartiallySigned<br>Expired<br>Completed<br>Archived<br>Disposed| | eEzsignfoldertypePrivacylevel | User<br>Usergroup |  Advanced filters that can be used in query parameter *sFilter*:  | Variable | |---| | fkiUserID | | sContactFirstname | | sContactLastname | | sUserFirstname | | sUserLastname | | sEzsigndocumentName |
         * @summary Retrieve Ezsignfolder list
         * @param {EzsignfolderGetListV1EOrderByEnum} [eOrderBy] Specify how you want the results to be sorted
         * @param {number} [iRowMax] 
         * @param {number} [iRowOffset] 
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {string} [sFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetListV1(eOrderBy?: EzsignfolderGetListV1EOrderByEnum, iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetListV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetListV1(eOrderBy, iRowMax, iRowOffset, acceptLanguage, sFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async ezsignfolderGetObjectV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetObjectV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetObjectV1(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetObjectV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async ezsignfolderGetObjectV2(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetObjectV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetObjectV2(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetObjectV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetObjectV3(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetObjectV3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetObjectV3(pkiEzsignfolderID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderGetObjectV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsignfoldersignerassociationsV1Request} ezsignfolderImportEzsignfoldersignerassociationsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, ezsignfolderImportEzsignfoldersignerassociationsV1Request: EzsignfolderImportEzsignfoldersignerassociationsV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderImportEzsignfoldersignerassociationsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID, ezsignfolderImportEzsignfoldersignerassociationsV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderImportEzsignfoldersignerassociationsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
         * @summary Import an Ezsigntemplatepackage in the Ezsignfolder.
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsigntemplatepackageV1Request} ezsignfolderImportEzsigntemplatepackageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID: number, ezsignfolderImportEzsigntemplatepackageV1Request: EzsignfolderImportEzsigntemplatepackageV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderImportEzsigntemplatepackageV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID, ezsignfolderImportEzsigntemplatepackageV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderImportEzsigntemplatepackageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reorder Ezsigndocuments in the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderReorderV1Request} ezsignfolderReorderV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async ezsignfolderReorderV1(pkiEzsignfolderID: number, ezsignfolderReorderV1Request: EzsignfolderReorderV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderReorderV1(pkiEzsignfolderID, ezsignfolderReorderV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderReorderV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reorder Ezsigndocuments in the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderReorderV2Request} ezsignfolderReorderV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderReorderV2(pkiEzsignfolderID: number, ezsignfolderReorderV2Request: EzsignfolderReorderV2Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderReorderV2(pkiEzsignfolderID, ezsignfolderReorderV2Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderReorderV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async ezsignfolderSendV1(pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderSendV1(pkiEzsignfolderID, ezsignfolderSendV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderSendV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV3Request} ezsignfolderSendV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderSendV3(pkiEzsignfolderID: number, ezsignfolderSendV3Request: EzsignfolderSendV3Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderSendV3(pkiEzsignfolderID, ezsignfolderSendV3Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderSendV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \"Non-completed\" Ezsigndocuments will be lost.
         * @summary Unsend the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderUnsendV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderUnsendV1(pkiEzsignfolderID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectEzsignfolderApi.ezsignfolderUnsendV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ObjectEzsignfolderApi - factory interface
 * @export
 */
export const ObjectEzsignfolderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObjectEzsignfolderApiFp(configuration)
    return {
        /**
         * 
         * @summary Archive the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderArchiveV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.ezsignfolderArchiveV1(pkiEzsignfolderID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download multiples files from an Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderBatchDownloadV1Request} ezsignfolderBatchDownloadV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderBatchDownloadV1(pkiEzsignfolderID: number, ezsignfolderBatchDownloadV1Request: EzsignfolderBatchDownloadV1Request, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.ezsignfolderBatchDownloadV1(pkiEzsignfolderID, ezsignfolderBatchDownloadV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfolder
         * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderCreateObjectV1Response> {
            return localVarFp.ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new Ezsignfolder
         * @param {EzsignfolderCreateObjectV2Request} ezsignfolderCreateObjectV2Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request: EzsignfolderCreateObjectV2Request, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderCreateObjectV2Response> {
            return localVarFp.ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new Ezsignfolder
         * @param {EzsignfolderCreateObjectV3Request} ezsignfolderCreateObjectV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV3(ezsignfolderCreateObjectV3Request: EzsignfolderCreateObjectV3Request, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderCreateObjectV3Response> {
            return localVarFp.ezsignfolderCreateObjectV3(ezsignfolderCreateObjectV3Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDeleteObjectV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.ezsignfolderDeleteObjectV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dispose Ezsignfolders
         * @param {EzsignfolderDisposeEzsignfoldersV1Request} ezsignfolderDisposeEzsignfoldersV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request: EzsignfolderDisposeEzsignfoldersV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dispose the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDisposeV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.ezsignfolderDisposeV1(pkiEzsignfolderID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderEditObjectV3Request} ezsignfolderEditObjectV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderEditObjectV3(pkiEzsignfolderID: number, ezsignfolderEditObjectV3Request: EzsignfolderEditObjectV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.ezsignfolderEditObjectV3(pkiEzsignfolderID, ezsignfolderEditObjectV3Request, options).then((request) => request(axios, basePath));
        },
        /**
         * End prematurely all Ezsigndocument of Ezsignfolder when some signatures are still required
         * @summary End prematurely
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderEndPrematurelyV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.ezsignfolderEndPrematurelyV1(pkiEzsignfolderID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
         * @summary Retrieve actionable elements for the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetActionableElementsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetActionableElementsV1Response> {
            return localVarFp.ezsignfolderGetActionableElementsV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Attachment count
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetAttachmentCountV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetAttachmentCountV1Response> {
            return localVarFp.ezsignfolderGetAttachmentCountV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Ezsignfolder\'s Attachments
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetAttachmentsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetAttachmentsV1Response> {
            return localVarFp.ezsignfolderGetAttachmentsV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Communication count
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetCommunicationCountV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetCommunicationCountV1Response> {
            return localVarFp.ezsignfolderGetCommunicationCountV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Communication list
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetCommunicationListV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetCommunicationListV1Response> {
            return localVarFp.ezsignfolderGetCommunicationListV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Ezsignfolder\'s Communicationrecipient
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetCommunicationrecipientsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetCommunicationrecipientsV1Response> {
            return localVarFp.ezsignfolderGetCommunicationrecipientsV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Ezsignfolder\'s Communicationsender
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetCommunicationsendersV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetCommunicationsendersV1Response> {
            return localVarFp.ezsignfolderGetCommunicationsendersV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsigndocuments
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetEzsigndocumentsV1Response> {
            return localVarFp.ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsignfoldersignerassociations
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetEzsignfoldersignerassociationsV1Response> {
            return localVarFp.ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the Ezsignsignatures that can be signed by the current user at the current step in the process
         * @summary Retrieve an existing Ezsignfolder\'s automatic Ezsignsignatures
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetEzsignsignaturesAutomaticV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetEzsignsignaturesAutomaticV1Response> {
            return localVarFp.ezsignfolderGetEzsignsignaturesAutomaticV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s forms data
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetFormsDataV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetFormsDataV1Response> {
            return localVarFp.ezsignfolderGetFormsDataV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent<br>Sent<br>PartiallySigned<br>Expired<br>Completed<br>Archived<br>Disposed| | eEzsignfoldertypePrivacylevel | User<br>Usergroup |  Advanced filters that can be used in query parameter *sFilter*:  | Variable | |---| | fkiUserID | | sContactFirstname | | sContactLastname | | sUserFirstname | | sUserLastname | | sEzsigndocumentName |
         * @summary Retrieve Ezsignfolder list
         * @param {EzsignfolderGetListV1EOrderByEnum} [eOrderBy] Specify how you want the results to be sorted
         * @param {number} [iRowMax] 
         * @param {number} [iRowOffset] 
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {string} [sFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetListV1(eOrderBy?: EzsignfolderGetListV1EOrderByEnum, iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetListV1Response> {
            return localVarFp.ezsignfolderGetListV1(eOrderBy, iRowMax, iRowOffset, acceptLanguage, sFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetObjectV1Response> {
            return localVarFp.ezsignfolderGetObjectV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV2(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetObjectV2Response> {
            return localVarFp.ezsignfolderGetObjectV2(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV3(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderGetObjectV3Response> {
            return localVarFp.ezsignfolderGetObjectV3(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsignfoldersignerassociationsV1Request} ezsignfolderImportEzsignfoldersignerassociationsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, ezsignfolderImportEzsignfoldersignerassociationsV1Request: EzsignfolderImportEzsignfoldersignerassociationsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderImportEzsignfoldersignerassociationsV1Response> {
            return localVarFp.ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID, ezsignfolderImportEzsignfoldersignerassociationsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
         * @summary Import an Ezsigntemplatepackage in the Ezsignfolder.
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsigntemplatepackageV1Request} ezsignfolderImportEzsigntemplatepackageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID: number, ezsignfolderImportEzsigntemplatepackageV1Request: EzsignfolderImportEzsigntemplatepackageV1Request, options?: RawAxiosRequestConfig): AxiosPromise<EzsignfolderImportEzsigntemplatepackageV1Response> {
            return localVarFp.ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID, ezsignfolderImportEzsigntemplatepackageV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reorder Ezsigndocuments in the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderReorderV1Request} ezsignfolderReorderV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderReorderV1(pkiEzsignfolderID: number, ezsignfolderReorderV1Request: EzsignfolderReorderV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.ezsignfolderReorderV1(pkiEzsignfolderID, ezsignfolderReorderV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reorder Ezsigndocuments in the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderReorderV2Request} ezsignfolderReorderV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderReorderV2(pkiEzsignfolderID: number, ezsignfolderReorderV2Request: EzsignfolderReorderV2Request, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.ezsignfolderReorderV2(pkiEzsignfolderID, ezsignfolderReorderV2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderSendV1(pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.ezsignfolderSendV1(pkiEzsignfolderID, ezsignfolderSendV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV3Request} ezsignfolderSendV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderSendV3(pkiEzsignfolderID: number, ezsignfolderSendV3Request: EzsignfolderSendV3Request, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.ezsignfolderSendV3(pkiEzsignfolderID, ezsignfolderSendV3Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \"Non-completed\" Ezsigndocuments will be lost.
         * @summary Unsend the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderUnsendV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.ezsignfolderUnsendV1(pkiEzsignfolderID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectEzsignfolderApi - object-oriented interface
 * @export
 * @class ObjectEzsignfolderApi
 * @extends {BaseAPI}
 */
export class ObjectEzsignfolderApi extends BaseAPI {
    /**
     * 
     * @summary Archive the Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderArchiveV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderArchiveV1(pkiEzsignfolderID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download multiples files from an Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderBatchDownloadV1Request} ezsignfolderBatchDownloadV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderBatchDownloadV1(pkiEzsignfolderID: number, ezsignfolderBatchDownloadV1Request: EzsignfolderBatchDownloadV1Request, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderBatchDownloadV1(pkiEzsignfolderID, ezsignfolderBatchDownloadV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @summary Create a new Ezsignfolder
     * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint allows to create one or many elements at once.
     * @summary Create a new Ezsignfolder
     * @param {EzsignfolderCreateObjectV2Request} ezsignfolderCreateObjectV2Request 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request: EzsignfolderCreateObjectV2Request, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint allows to create one or many elements at once.
     * @summary Create a new Ezsignfolder
     * @param {EzsignfolderCreateObjectV3Request} ezsignfolderCreateObjectV3Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderCreateObjectV3(ezsignfolderCreateObjectV3Request: EzsignfolderCreateObjectV3Request, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderCreateObjectV3(ezsignfolderCreateObjectV3Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderDeleteObjectV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderDeleteObjectV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dispose Ezsignfolders
     * @param {EzsignfolderDisposeEzsignfoldersV1Request} ezsignfolderDisposeEzsignfoldersV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request: EzsignfolderDisposeEzsignfoldersV1Request, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dispose the Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderDisposeV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderDisposeV1(pkiEzsignfolderID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderEditObjectV3Request} ezsignfolderEditObjectV3Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderEditObjectV3(pkiEzsignfolderID: number, ezsignfolderEditObjectV3Request: EzsignfolderEditObjectV3Request, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderEditObjectV3(pkiEzsignfolderID, ezsignfolderEditObjectV3Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End prematurely all Ezsigndocument of Ezsignfolder when some signatures are still required
     * @summary End prematurely
     * @param {number} pkiEzsignfolderID 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderEndPrematurelyV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderEndPrematurelyV1(pkiEzsignfolderID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
     * @summary Retrieve actionable elements for the Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetActionableElementsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetActionableElementsV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Attachment count
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetAttachmentCountV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetAttachmentCountV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Ezsignfolder\'s Attachments
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetAttachmentsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetAttachmentsV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Communication count
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetCommunicationCountV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetCommunicationCountV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Communication list
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetCommunicationListV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetCommunicationListV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Ezsignfolder\'s Communicationrecipient
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetCommunicationrecipientsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetCommunicationrecipientsV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Ezsignfolder\'s Communicationsender
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetCommunicationsendersV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetCommunicationsendersV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder\'s Ezsigndocuments
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder\'s Ezsignfoldersignerassociations
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the Ezsignsignatures that can be signed by the current user at the current step in the process
     * @summary Retrieve an existing Ezsignfolder\'s automatic Ezsignsignatures
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetEzsignsignaturesAutomaticV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetEzsignsignaturesAutomaticV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder\'s forms data
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetFormsDataV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetFormsDataV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent<br>Sent<br>PartiallySigned<br>Expired<br>Completed<br>Archived<br>Disposed| | eEzsignfoldertypePrivacylevel | User<br>Usergroup |  Advanced filters that can be used in query parameter *sFilter*:  | Variable | |---| | fkiUserID | | sContactFirstname | | sContactLastname | | sUserFirstname | | sUserLastname | | sEzsigndocumentName |
     * @summary Retrieve Ezsignfolder list
     * @param {EzsignfolderGetListV1EOrderByEnum} [eOrderBy] Specify how you want the results to be sorted
     * @param {number} [iRowMax] 
     * @param {number} [iRowOffset] 
     * @param {HeaderAcceptLanguage} [acceptLanguage] 
     * @param {string} [sFilter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetListV1(eOrderBy?: EzsignfolderGetListV1EOrderByEnum, iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetListV1(eOrderBy, iRowMax, iRowOffset, acceptLanguage, sFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetObjectV1(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetObjectV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetObjectV2(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetObjectV2(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetObjectV3(pkiEzsignfolderID: number, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetObjectV3(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderImportEzsignfoldersignerassociationsV1Request} ezsignfolderImportEzsignfoldersignerassociationsV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, ezsignfolderImportEzsignfoldersignerassociationsV1Request: EzsignfolderImportEzsignfoldersignerassociationsV1Request, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID, ezsignfolderImportEzsignfoldersignerassociationsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
     * @summary Import an Ezsigntemplatepackage in the Ezsignfolder.
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderImportEzsigntemplatepackageV1Request} ezsignfolderImportEzsigntemplatepackageV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID: number, ezsignfolderImportEzsigntemplatepackageV1Request: EzsignfolderImportEzsigntemplatepackageV1Request, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID, ezsignfolderImportEzsigntemplatepackageV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reorder Ezsigndocuments in the Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderReorderV1Request} ezsignfolderReorderV1Request 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderReorderV1(pkiEzsignfolderID: number, ezsignfolderReorderV1Request: EzsignfolderReorderV1Request, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderReorderV1(pkiEzsignfolderID, ezsignfolderReorderV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reorder Ezsigndocuments in the Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderReorderV2Request} ezsignfolderReorderV2Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderReorderV2(pkiEzsignfolderID: number, ezsignfolderReorderV2Request: EzsignfolderReorderV2Request, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderReorderV2(pkiEzsignfolderID, ezsignfolderReorderV2Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send the Ezsignfolder to the signatories for signature
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderSendV1(pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderSendV1(pkiEzsignfolderID, ezsignfolderSendV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send the Ezsignfolder to the signatories for signature
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderSendV3Request} ezsignfolderSendV3Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderSendV3(pkiEzsignfolderID: number, ezsignfolderSendV3Request: EzsignfolderSendV3Request, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderSendV3(pkiEzsignfolderID, ezsignfolderSendV3Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \"Non-completed\" Ezsigndocuments will be lost.
     * @summary Unsend the Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderUnsendV1(pkiEzsignfolderID: number, body: object, options?: RawAxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderUnsendV1(pkiEzsignfolderID, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EzsignfolderGetListV1EOrderByEnum = {
    pkiEzsignfolderID_ASC: 'pkiEzsignfolderID_ASC',
    pkiEzsignfolderID_DESC: 'pkiEzsignfolderID_DESC',
    sEzsignfolderDescription_ASC: 'sEzsignfolderDescription_ASC',
    sEzsignfolderDescription_DESC: 'sEzsignfolderDescription_DESC',
    dtCreatedDate_ASC: 'dtCreatedDate_ASC',
    dtCreatedDate_DESC: 'dtCreatedDate_DESC',
    fkiEzsignfoldertypeID_ASC: 'fkiEzsignfoldertypeID_ASC',
    fkiEzsignfoldertypeID_DESC: 'fkiEzsignfoldertypeID_DESC',
    sEzsignfoldertypeNameX_ASC: 'sEzsignfoldertypeNameX_ASC',
    sEzsignfoldertypeNameX_DESC: 'sEzsignfoldertypeNameX_DESC',
    eEzsignfolderStep_ASC: 'eEzsignfolderStep_ASC',
    eEzsignfolderStep_DESC: 'eEzsignfolderStep_DESC',
    dtEzsignfolderSentdate_ASC: 'dtEzsignfolderSentdate_ASC',
    dtEzsignfolderSentdate_DESC: 'dtEzsignfolderSentdate_DESC',
    dtEzsignfolderDuedate_ASC: 'dtEzsignfolderDuedate_ASC',
    dtEzsignfolderDuedate_DESC: 'dtEzsignfolderDuedate_DESC',
    iEzsigndocument_ASC: 'iEzsigndocument_ASC',
    iEzsigndocument_DESC: 'iEzsigndocument_DESC',
    iEzsigndocumentEdm_ASC: 'iEzsigndocumentEdm_ASC',
    iEzsigndocumentEdm_DESC: 'iEzsigndocumentEdm_DESC',
    iEzsignsignature_ASC: 'iEzsignsignature_ASC',
    iEzsignsignature_DESC: 'iEzsignsignature_DESC',
    iEzsignsignatureSigned_ASC: 'iEzsignsignatureSigned_ASC',
    iEzsignsignatureSigned_DESC: 'iEzsignsignatureSigned_DESC',
    iEzsignformfieldgroup_ASC: 'iEzsignformfieldgroup_ASC',
    iEzsignformfieldgroup_DESC: 'iEzsignformfieldgroup_DESC',
    iEzsignformfieldgroupCompleted_ASC: 'iEzsignformfieldgroupCompleted_ASC',
    iEzsignformfieldgroupCompleted_DESC: 'iEzsignformfieldgroupCompleted_DESC',
    dEzsignfolderCompletedpercentage_ASC: 'dEzsignfolderCompletedpercentage_ASC',
    dEzsignfolderCompletedpercentage_DESC: 'dEzsignfolderCompletedpercentage_DESC',
    dEzsignfolderFormcompletedpercentage_ASC: 'dEzsignfolderFormcompletedpercentage_ASC',
    dEzsignfolderFormcompletedpercentage_DESC: 'dEzsignfolderFormcompletedpercentage_DESC',
    dEzsignfolderSignaturecompletedpercentage_ASC: 'dEzsignfolderSignaturecompletedpercentage_ASC',
    dEzsignfolderSignaturecompletedpercentagee_DESC: 'dEzsignfolderSignaturecompletedpercentagee_DESC'
} as const;
export type EzsignfolderGetListV1EOrderByEnum = typeof EzsignfolderGetListV1EOrderByEnum[keyof typeof EzsignfolderGetListV1EOrderByEnum];
