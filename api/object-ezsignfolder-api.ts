/* tslint:disable */
/* eslint-disable */
/**
 * eZmax API Definition (Full)
 * This API expose all the functionnalities for the eZmax and eZsign applications.
 *
 * The version of the OpenAPI document: 1.1.17
 * Contact: support-api@ezmax.ca
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { CommonResponseError } from '../model';
// @ts-ignore
import { EzsignfolderArchiveV1Response } from '../model';
// @ts-ignore
import { EzsignfolderBatchDownloadV1Request } from '../model';
// @ts-ignore
import { EzsignfolderCreateObjectV1Request } from '../model';
// @ts-ignore
import { EzsignfolderCreateObjectV1Response } from '../model';
// @ts-ignore
import { EzsignfolderCreateObjectV2Request } from '../model';
// @ts-ignore
import { EzsignfolderCreateObjectV2Response } from '../model';
// @ts-ignore
import { EzsignfolderDeleteObjectV1Response } from '../model';
// @ts-ignore
import { EzsignfolderDisposeEzsignfoldersV1Request } from '../model';
// @ts-ignore
import { EzsignfolderDisposeEzsignfoldersV1Response } from '../model';
// @ts-ignore
import { EzsignfolderDisposeV1Response } from '../model';
// @ts-ignore
import { EzsignfolderEditObjectV1Request } from '../model';
// @ts-ignore
import { EzsignfolderEditObjectV1Response } from '../model';
// @ts-ignore
import { EzsignfolderGetActionableElementsV1Response } from '../model';
// @ts-ignore
import { EzsignfolderGetEzsigndocumentsV1Response } from '../model';
// @ts-ignore
import { EzsignfolderGetEzsignfoldersignerassociationsV1Response } from '../model';
// @ts-ignore
import { EzsignfolderGetFormsDataV1Response } from '../model';
// @ts-ignore
import { EzsignfolderGetListV1Response } from '../model';
// @ts-ignore
import { EzsignfolderGetObjectV1Response } from '../model';
// @ts-ignore
import { EzsignfolderGetObjectV2Response } from '../model';
// @ts-ignore
import { EzsignfolderImportEzsignfoldersignerassociationsV1Request } from '../model';
// @ts-ignore
import { EzsignfolderImportEzsignfoldersignerassociationsV1Response } from '../model';
// @ts-ignore
import { EzsignfolderImportEzsigntemplatepackageV1Request } from '../model';
// @ts-ignore
import { EzsignfolderImportEzsigntemplatepackageV1Response } from '../model';
// @ts-ignore
import { EzsignfolderReorderV1Request } from '../model';
// @ts-ignore
import { EzsignfolderReorderV1Response } from '../model';
// @ts-ignore
import { EzsignfolderSendV1Request } from '../model';
// @ts-ignore
import { EzsignfolderSendV1Response } from '../model';
// @ts-ignore
import { EzsignfolderSendV2Request } from '../model';
// @ts-ignore
import { EzsignfolderSendV2Response } from '../model';
// @ts-ignore
import { EzsignfolderSendV3Request } from '../model';
// @ts-ignore
import { EzsignfolderSendV3Response } from '../model';
// @ts-ignore
import { EzsignfolderUnsendV1Response } from '../model';
// @ts-ignore
import { HeaderAcceptLanguage } from '../model';
// @ts-ignore
import { RequestSignature, IHeadersData } from '../api/request-signature';
/**
 * ObjectEzsignfolderApi - axios parameter creator
 * @export
 */
export const ObjectEzsignfolderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderArchiveV1: async (pkiEzsignfolderID: number, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderArchiveV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ezsignfolderArchiveV1', 'body', body)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/archive`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download multiples files from an Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderBatchDownloadV1Request} ezsignfolderBatchDownloadV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderBatchDownloadV1: async (pkiEzsignfolderID: number, ezsignfolderBatchDownloadV1Request: EzsignfolderBatchDownloadV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderBatchDownloadV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderBatchDownloadV1Request' is not null or undefined
            assertParamExists('ezsignfolderBatchDownloadV1', 'ezsignfolderBatchDownloadV1Request', ezsignfolderBatchDownloadV1Request)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/batchDownload`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderBatchDownloadV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfolder
         * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV1: async (ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ezsignfolderCreateObjectV1Request' is not null or undefined
            assertParamExists('ezsignfolderCreateObjectV1', 'ezsignfolderCreateObjectV1Request', ezsignfolderCreateObjectV1Request)
            const localVarPath = `/1/object/ezsignfolder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderCreateObjectV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new Ezsignfolder
         * @param {EzsignfolderCreateObjectV2Request} ezsignfolderCreateObjectV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV2: async (ezsignfolderCreateObjectV2Request: EzsignfolderCreateObjectV2Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ezsignfolderCreateObjectV2Request' is not null or undefined
            assertParamExists('ezsignfolderCreateObjectV2', 'ezsignfolderCreateObjectV2Request', ezsignfolderCreateObjectV2Request)
            const localVarPath = `/2/object/ezsignfolder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderCreateObjectV2Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDeleteObjectV1: async (pkiEzsignfolderID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderDeleteObjectV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'DELETE' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dispose Ezsignfolders
         * @param {EzsignfolderDisposeEzsignfoldersV1Request} ezsignfolderDisposeEzsignfoldersV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDisposeEzsignfoldersV1: async (ezsignfolderDisposeEzsignfoldersV1Request: EzsignfolderDisposeEzsignfoldersV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ezsignfolderDisposeEzsignfoldersV1Request' is not null or undefined
            assertParamExists('ezsignfolderDisposeEzsignfoldersV1', 'ezsignfolderDisposeEzsignfoldersV1Request', ezsignfolderDisposeEzsignfoldersV1Request)
            const localVarPath = `/1/object/ezsignfolder/disposeEzsignfolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderDisposeEzsignfoldersV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dispose the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDisposeV1: async (pkiEzsignfolderID: number, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderDisposeV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ezsignfolderDisposeV1', 'body', body)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/dispose`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderEditObjectV1Request} ezsignfolderEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderEditObjectV1: async (pkiEzsignfolderID: number, ezsignfolderEditObjectV1Request: EzsignfolderEditObjectV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderEditObjectV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderEditObjectV1Request' is not null or undefined
            assertParamExists('ezsignfolderEditObjectV1', 'ezsignfolderEditObjectV1Request', ezsignfolderEditObjectV1Request)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderEditObjectV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'PUT' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
         * @summary Retrieve actionable elements for the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetActionableElementsV1: async (pkiEzsignfolderID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetActionableElementsV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getActionableElements`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsigndocuments
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetEzsigndocumentsV1: async (pkiEzsignfolderID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetEzsigndocumentsV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsigndocuments`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsignfoldersignerassociations
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetEzsignfoldersignerassociationsV1: async (pkiEzsignfolderID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetEzsignfoldersignerassociationsV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsignfoldersignerassociations`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s forms data
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetFormsDataV1: async (pkiEzsignfolderID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetFormsDataV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/getFormsData`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent<br>Sent<br>PartiallySigned<br>Expired<br>Completed<br>Archived<br>Disposed| | eEzsignfoldertypePrivacylevel | User<br>Usergroup |
         * @summary Retrieve Ezsignfolder list
         * @param {'pkiEzsignfolderID_ASC' | 'pkiEzsignfolderID_DESC' | 'sEzsignfolderDescription_ASC' | 'sEzsignfolderDescription_DESC' | 'dtCreatedDate_ASC' | 'dtCreatedDate_DESC' | 'fkiEzsignfoldertypeID_ASC' | 'fkiEzsignfoldertypeID_DESC' | 'sEzsignfoldertypeNameX_ASC' | 'sEzsignfoldertypeNameX_DESC' | 'eEzsignfolderStep_ASC' | 'eEzsignfolderStep_DESC' | 'dtEzsignfolderSentdate_ASC' | 'dtEzsignfolderSentdate_DESC' | 'dtDueDate_ASC' | 'dtDueDate_DESC' | 'iTotalDocument_ASC' | 'iTotalDocument_DESC' | 'iTotalDocumentEdm_ASC' | 'iTotalDocumentEdm_DESC' | 'iTotalSignature_ASC' | 'iTotalSignature_DESC' | 'iTotalSignatureSigned_ASC' | 'iTotalSignatureSigned_DESC'} [eOrderBy] Specify how you want the results to be sorted
         * @param {number} [iRowMax] 
         * @param {number} [iRowOffset] 
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {string} [sFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetListV1: async (eOrderBy?: 'pkiEzsignfolderID_ASC' | 'pkiEzsignfolderID_DESC' | 'sEzsignfolderDescription_ASC' | 'sEzsignfolderDescription_DESC' | 'dtCreatedDate_ASC' | 'dtCreatedDate_DESC' | 'fkiEzsignfoldertypeID_ASC' | 'fkiEzsignfoldertypeID_DESC' | 'sEzsignfoldertypeNameX_ASC' | 'sEzsignfoldertypeNameX_DESC' | 'eEzsignfolderStep_ASC' | 'eEzsignfolderStep_DESC' | 'dtEzsignfolderSentdate_ASC' | 'dtEzsignfolderSentdate_DESC' | 'dtDueDate_ASC' | 'dtDueDate_DESC' | 'iTotalDocument_ASC' | 'iTotalDocument_DESC' | 'iTotalDocumentEdm_ASC' | 'iTotalDocumentEdm_DESC' | 'iTotalSignature_ASC' | 'iTotalSignature_DESC' | 'iTotalSignatureSigned_ASC' | 'iTotalSignatureSigned_DESC', iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1/object/ezsignfolder/getList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (eOrderBy !== undefined) {
                localVarQueryParameter['eOrderBy'] = eOrderBy;
            }

            if (iRowMax !== undefined) {
                localVarQueryParameter['iRowMax'] = iRowMax;
            }

            if (iRowOffset !== undefined) {
                localVarQueryParameter['iRowOffset'] = iRowOffset;
            }

            if (sFilter !== undefined) {
                localVarQueryParameter['sFilter'] = sFilter;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string' 
                    ? acceptLanguage 
                    : JSON.stringify(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV1: async (pkiEzsignfolderID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetObjectV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV2: async (pkiEzsignfolderID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderGetObjectV2', 'pkiEzsignfolderID', pkiEzsignfolderID)
            const localVarPath = `/2/object/ezsignfolder/{pkiEzsignfolderID}`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsignfoldersignerassociationsV1Request} ezsignfolderImportEzsignfoldersignerassociationsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderImportEzsignfoldersignerassociationsV1: async (pkiEzsignfolderID: number, ezsignfolderImportEzsignfoldersignerassociationsV1Request: EzsignfolderImportEzsignfoldersignerassociationsV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderImportEzsignfoldersignerassociationsV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderImportEzsignfoldersignerassociationsV1Request' is not null or undefined
            assertParamExists('ezsignfolderImportEzsignfoldersignerassociationsV1', 'ezsignfolderImportEzsignfoldersignerassociationsV1Request', ezsignfolderImportEzsignfoldersignerassociationsV1Request)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/importEzsignfoldersignerassociations`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderImportEzsignfoldersignerassociationsV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
         * @summary Import an Ezsigntemplatepackage in the Ezsignfolder.
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsigntemplatepackageV1Request} ezsignfolderImportEzsigntemplatepackageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderImportEzsigntemplatepackageV1: async (pkiEzsignfolderID: number, ezsignfolderImportEzsigntemplatepackageV1Request: EzsignfolderImportEzsigntemplatepackageV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderImportEzsigntemplatepackageV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderImportEzsigntemplatepackageV1Request' is not null or undefined
            assertParamExists('ezsignfolderImportEzsigntemplatepackageV1', 'ezsignfolderImportEzsigntemplatepackageV1Request', ezsignfolderImportEzsigntemplatepackageV1Request)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/importEzsigntemplatepackage`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderImportEzsigntemplatepackageV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reorder Ezsigndocuments in the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderReorderV1Request} ezsignfolderReorderV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderReorderV1: async (pkiEzsignfolderID: number, ezsignfolderReorderV1Request: EzsignfolderReorderV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderReorderV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderReorderV1Request' is not null or undefined
            assertParamExists('ezsignfolderReorderV1', 'ezsignfolderReorderV1Request', ezsignfolderReorderV1Request)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/reorder`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderReorderV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderSendV1: async (pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderSendV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderSendV1Request' is not null or undefined
            assertParamExists('ezsignfolderSendV1', 'ezsignfolderSendV1Request', ezsignfolderSendV1Request)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/send`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderSendV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV2Request} ezsignfolderSendV2Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderSendV2: async (pkiEzsignfolderID: number, ezsignfolderSendV2Request: EzsignfolderSendV2Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderSendV2', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderSendV2Request' is not null or undefined
            assertParamExists('ezsignfolderSendV2', 'ezsignfolderSendV2Request', ezsignfolderSendV2Request)
            const localVarPath = `/2/object/ezsignfolder/{pkiEzsignfolderID}/send`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderSendV2Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV3Request} ezsignfolderSendV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderSendV3: async (pkiEzsignfolderID: number, ezsignfolderSendV3Request: EzsignfolderSendV3Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderSendV3', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'ezsignfolderSendV3Request' is not null or undefined
            assertParamExists('ezsignfolderSendV3', 'ezsignfolderSendV3Request', ezsignfolderSendV3Request)
            const localVarPath = `/3/object/ezsignfolder/{pkiEzsignfolderID}/send`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ezsignfolderSendV3Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \"Non-completed\" Ezsigndocuments will be lost.
         * @summary Unsend the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderUnsendV1: async (pkiEzsignfolderID: number, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiEzsignfolderID' is not null or undefined
            assertParamExists('ezsignfolderUnsendV1', 'pkiEzsignfolderID', pkiEzsignfolderID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ezsignfolderUnsendV1', 'body', body)
            const localVarPath = `/1/object/ezsignfolder/{pkiEzsignfolderID}/unsend`
                .replace(`{${"pkiEzsignfolderID"}}`, encodeURIComponent(String(pkiEzsignfolderID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectEzsignfolderApi - functional programming interface
 * @export
 */
export const ObjectEzsignfolderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObjectEzsignfolderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Archive the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderArchiveV1(pkiEzsignfolderID: number, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderArchiveV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderArchiveV1(pkiEzsignfolderID, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download multiples files from an Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderBatchDownloadV1Request} ezsignfolderBatchDownloadV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderBatchDownloadV1(pkiEzsignfolderID: number, ezsignfolderBatchDownloadV1Request: EzsignfolderBatchDownloadV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderBatchDownloadV1(pkiEzsignfolderID, ezsignfolderBatchDownloadV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfolder
         * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderCreateObjectV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new Ezsignfolder
         * @param {EzsignfolderCreateObjectV2Request} ezsignfolderCreateObjectV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request: EzsignfolderCreateObjectV2Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderCreateObjectV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderDeleteObjectV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderDeleteObjectV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderDeleteObjectV1(pkiEzsignfolderID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Dispose Ezsignfolders
         * @param {EzsignfolderDisposeEzsignfoldersV1Request} ezsignfolderDisposeEzsignfoldersV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request: EzsignfolderDisposeEzsignfoldersV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderDisposeEzsignfoldersV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Dispose the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderDisposeV1(pkiEzsignfolderID: number, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderDisposeV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderDisposeV1(pkiEzsignfolderID, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderEditObjectV1Request} ezsignfolderEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderEditObjectV1(pkiEzsignfolderID: number, ezsignfolderEditObjectV1Request: EzsignfolderEditObjectV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderEditObjectV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderEditObjectV1(pkiEzsignfolderID, ezsignfolderEditObjectV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
         * @summary Retrieve actionable elements for the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetActionableElementsV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetActionableElementsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetActionableElementsV1(pkiEzsignfolderID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsigndocuments
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetEzsigndocumentsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsignfoldersignerassociations
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetEzsignfoldersignerassociationsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s forms data
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetFormsDataV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetFormsDataV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetFormsDataV1(pkiEzsignfolderID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent<br>Sent<br>PartiallySigned<br>Expired<br>Completed<br>Archived<br>Disposed| | eEzsignfoldertypePrivacylevel | User<br>Usergroup |
         * @summary Retrieve Ezsignfolder list
         * @param {'pkiEzsignfolderID_ASC' | 'pkiEzsignfolderID_DESC' | 'sEzsignfolderDescription_ASC' | 'sEzsignfolderDescription_DESC' | 'dtCreatedDate_ASC' | 'dtCreatedDate_DESC' | 'fkiEzsignfoldertypeID_ASC' | 'fkiEzsignfoldertypeID_DESC' | 'sEzsignfoldertypeNameX_ASC' | 'sEzsignfoldertypeNameX_DESC' | 'eEzsignfolderStep_ASC' | 'eEzsignfolderStep_DESC' | 'dtEzsignfolderSentdate_ASC' | 'dtEzsignfolderSentdate_DESC' | 'dtDueDate_ASC' | 'dtDueDate_DESC' | 'iTotalDocument_ASC' | 'iTotalDocument_DESC' | 'iTotalDocumentEdm_ASC' | 'iTotalDocumentEdm_DESC' | 'iTotalSignature_ASC' | 'iTotalSignature_DESC' | 'iTotalSignatureSigned_ASC' | 'iTotalSignatureSigned_DESC'} [eOrderBy] Specify how you want the results to be sorted
         * @param {number} [iRowMax] 
         * @param {number} [iRowOffset] 
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {string} [sFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetListV1(eOrderBy?: 'pkiEzsignfolderID_ASC' | 'pkiEzsignfolderID_DESC' | 'sEzsignfolderDescription_ASC' | 'sEzsignfolderDescription_DESC' | 'dtCreatedDate_ASC' | 'dtCreatedDate_DESC' | 'fkiEzsignfoldertypeID_ASC' | 'fkiEzsignfoldertypeID_DESC' | 'sEzsignfoldertypeNameX_ASC' | 'sEzsignfoldertypeNameX_DESC' | 'eEzsignfolderStep_ASC' | 'eEzsignfolderStep_DESC' | 'dtEzsignfolderSentdate_ASC' | 'dtEzsignfolderSentdate_DESC' | 'dtDueDate_ASC' | 'dtDueDate_DESC' | 'iTotalDocument_ASC' | 'iTotalDocument_DESC' | 'iTotalDocumentEdm_ASC' | 'iTotalDocumentEdm_DESC' | 'iTotalSignature_ASC' | 'iTotalSignature_DESC' | 'iTotalSignatureSigned_ASC' | 'iTotalSignatureSigned_DESC', iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetListV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetListV1(eOrderBy, iRowMax, iRowOffset, acceptLanguage, sFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async ezsignfolderGetObjectV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetObjectV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetObjectV1(pkiEzsignfolderID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderGetObjectV2(pkiEzsignfolderID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderGetObjectV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderGetObjectV2(pkiEzsignfolderID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsignfoldersignerassociationsV1Request} ezsignfolderImportEzsignfoldersignerassociationsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, ezsignfolderImportEzsignfoldersignerassociationsV1Request: EzsignfolderImportEzsignfoldersignerassociationsV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderImportEzsignfoldersignerassociationsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID, ezsignfolderImportEzsignfoldersignerassociationsV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
         * @summary Import an Ezsigntemplatepackage in the Ezsignfolder.
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsigntemplatepackageV1Request} ezsignfolderImportEzsigntemplatepackageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID: number, ezsignfolderImportEzsigntemplatepackageV1Request: EzsignfolderImportEzsigntemplatepackageV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderImportEzsigntemplatepackageV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID, ezsignfolderImportEzsigntemplatepackageV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reorder Ezsigndocuments in the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderReorderV1Request} ezsignfolderReorderV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderReorderV1(pkiEzsignfolderID: number, ezsignfolderReorderV1Request: EzsignfolderReorderV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderReorderV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderReorderV1(pkiEzsignfolderID, ezsignfolderReorderV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async ezsignfolderSendV1(pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderSendV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderSendV1(pkiEzsignfolderID, ezsignfolderSendV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV2Request} ezsignfolderSendV2Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async ezsignfolderSendV2(pkiEzsignfolderID: number, ezsignfolderSendV2Request: EzsignfolderSendV2Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderSendV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderSendV2(pkiEzsignfolderID, ezsignfolderSendV2Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV3Request} ezsignfolderSendV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderSendV3(pkiEzsignfolderID: number, ezsignfolderSendV3Request: EzsignfolderSendV3Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderSendV3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderSendV3(pkiEzsignfolderID, ezsignfolderSendV3Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \"Non-completed\" Ezsigndocuments will be lost.
         * @summary Unsend the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ezsignfolderUnsendV1(pkiEzsignfolderID: number, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EzsignfolderUnsendV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ezsignfolderUnsendV1(pkiEzsignfolderID, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ObjectEzsignfolderApi - factory interface
 * @export
 */
export const ObjectEzsignfolderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObjectEzsignfolderApiFp(configuration)
    return {
        /**
         * 
         * @summary Archive the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderArchiveV1(pkiEzsignfolderID: number, body: object, options?: any): AxiosPromise<EzsignfolderArchiveV1Response> {
            return localVarFp.ezsignfolderArchiveV1(pkiEzsignfolderID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download multiples files from an Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderBatchDownloadV1Request} ezsignfolderBatchDownloadV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderBatchDownloadV1(pkiEzsignfolderID: number, ezsignfolderBatchDownloadV1Request: EzsignfolderBatchDownloadV1Request, options?: any): AxiosPromise<File> {
            return localVarFp.ezsignfolderBatchDownloadV1(pkiEzsignfolderID, ezsignfolderBatchDownloadV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
         * @summary Create a new Ezsignfolder
         * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options?: any): AxiosPromise<EzsignfolderCreateObjectV1Response> {
            return localVarFp.ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new Ezsignfolder
         * @param {EzsignfolderCreateObjectV2Request} ezsignfolderCreateObjectV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request: EzsignfolderCreateObjectV2Request, options?: any): AxiosPromise<EzsignfolderCreateObjectV2Response> {
            return localVarFp.ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDeleteObjectV1(pkiEzsignfolderID: number, options?: any): AxiosPromise<EzsignfolderDeleteObjectV1Response> {
            return localVarFp.ezsignfolderDeleteObjectV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dispose Ezsignfolders
         * @param {EzsignfolderDisposeEzsignfoldersV1Request} ezsignfolderDisposeEzsignfoldersV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request: EzsignfolderDisposeEzsignfoldersV1Request, options?: any): AxiosPromise<EzsignfolderDisposeEzsignfoldersV1Response> {
            return localVarFp.ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dispose the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderDisposeV1(pkiEzsignfolderID: number, body: object, options?: any): AxiosPromise<EzsignfolderDisposeV1Response> {
            return localVarFp.ezsignfolderDisposeV1(pkiEzsignfolderID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderEditObjectV1Request} ezsignfolderEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderEditObjectV1(pkiEzsignfolderID: number, ezsignfolderEditObjectV1Request: EzsignfolderEditObjectV1Request, options?: any): AxiosPromise<EzsignfolderEditObjectV1Response> {
            return localVarFp.ezsignfolderEditObjectV1(pkiEzsignfolderID, ezsignfolderEditObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
         * @summary Retrieve actionable elements for the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetActionableElementsV1(pkiEzsignfolderID: number, options?: any): AxiosPromise<EzsignfolderGetActionableElementsV1Response> {
            return localVarFp.ezsignfolderGetActionableElementsV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsigndocuments
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID: number, options?: any): AxiosPromise<EzsignfolderGetEzsigndocumentsV1Response> {
            return localVarFp.ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s Ezsignfoldersignerassociations
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, options?: any): AxiosPromise<EzsignfolderGetEzsignfoldersignerassociationsV1Response> {
            return localVarFp.ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder\'s forms data
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetFormsDataV1(pkiEzsignfolderID: number, options?: any): AxiosPromise<EzsignfolderGetFormsDataV1Response> {
            return localVarFp.ezsignfolderGetFormsDataV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent<br>Sent<br>PartiallySigned<br>Expired<br>Completed<br>Archived<br>Disposed| | eEzsignfoldertypePrivacylevel | User<br>Usergroup |
         * @summary Retrieve Ezsignfolder list
         * @param {'pkiEzsignfolderID_ASC' | 'pkiEzsignfolderID_DESC' | 'sEzsignfolderDescription_ASC' | 'sEzsignfolderDescription_DESC' | 'dtCreatedDate_ASC' | 'dtCreatedDate_DESC' | 'fkiEzsignfoldertypeID_ASC' | 'fkiEzsignfoldertypeID_DESC' | 'sEzsignfoldertypeNameX_ASC' | 'sEzsignfoldertypeNameX_DESC' | 'eEzsignfolderStep_ASC' | 'eEzsignfolderStep_DESC' | 'dtEzsignfolderSentdate_ASC' | 'dtEzsignfolderSentdate_DESC' | 'dtDueDate_ASC' | 'dtDueDate_DESC' | 'iTotalDocument_ASC' | 'iTotalDocument_DESC' | 'iTotalDocumentEdm_ASC' | 'iTotalDocumentEdm_DESC' | 'iTotalSignature_ASC' | 'iTotalSignature_DESC' | 'iTotalSignatureSigned_ASC' | 'iTotalSignatureSigned_DESC'} [eOrderBy] Specify how you want the results to be sorted
         * @param {number} [iRowMax] 
         * @param {number} [iRowOffset] 
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {string} [sFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetListV1(eOrderBy?: 'pkiEzsignfolderID_ASC' | 'pkiEzsignfolderID_DESC' | 'sEzsignfolderDescription_ASC' | 'sEzsignfolderDescription_DESC' | 'dtCreatedDate_ASC' | 'dtCreatedDate_DESC' | 'fkiEzsignfoldertypeID_ASC' | 'fkiEzsignfoldertypeID_DESC' | 'sEzsignfoldertypeNameX_ASC' | 'sEzsignfoldertypeNameX_DESC' | 'eEzsignfolderStep_ASC' | 'eEzsignfolderStep_DESC' | 'dtEzsignfolderSentdate_ASC' | 'dtEzsignfolderSentdate_DESC' | 'dtDueDate_ASC' | 'dtDueDate_DESC' | 'iTotalDocument_ASC' | 'iTotalDocument_DESC' | 'iTotalDocumentEdm_ASC' | 'iTotalDocumentEdm_DESC' | 'iTotalSignature_ASC' | 'iTotalSignature_DESC' | 'iTotalSignatureSigned_ASC' | 'iTotalSignatureSigned_DESC', iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options?: any): AxiosPromise<EzsignfolderGetListV1Response> {
            return localVarFp.ezsignfolderGetListV1(eOrderBy, iRowMax, iRowOffset, acceptLanguage, sFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV1(pkiEzsignfolderID: number, options?: any): AxiosPromise<EzsignfolderGetObjectV1Response> {
            return localVarFp.ezsignfolderGetObjectV1(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderGetObjectV2(pkiEzsignfolderID: number, options?: any): AxiosPromise<EzsignfolderGetObjectV2Response> {
            return localVarFp.ezsignfolderGetObjectV2(pkiEzsignfolderID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsignfoldersignerassociationsV1Request} ezsignfolderImportEzsignfoldersignerassociationsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, ezsignfolderImportEzsignfoldersignerassociationsV1Request: EzsignfolderImportEzsignfoldersignerassociationsV1Request, options?: any): AxiosPromise<EzsignfolderImportEzsignfoldersignerassociationsV1Response> {
            return localVarFp.ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID, ezsignfolderImportEzsignfoldersignerassociationsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
         * @summary Import an Ezsigntemplatepackage in the Ezsignfolder.
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderImportEzsigntemplatepackageV1Request} ezsignfolderImportEzsigntemplatepackageV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID: number, ezsignfolderImportEzsigntemplatepackageV1Request: EzsignfolderImportEzsigntemplatepackageV1Request, options?: any): AxiosPromise<EzsignfolderImportEzsigntemplatepackageV1Response> {
            return localVarFp.ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID, ezsignfolderImportEzsigntemplatepackageV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reorder Ezsigndocuments in the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderReorderV1Request} ezsignfolderReorderV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderReorderV1(pkiEzsignfolderID: number, ezsignfolderReorderV1Request: EzsignfolderReorderV1Request, options?: any): AxiosPromise<EzsignfolderReorderV1Response> {
            return localVarFp.ezsignfolderReorderV1(pkiEzsignfolderID, ezsignfolderReorderV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderSendV1(pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options?: any): AxiosPromise<EzsignfolderSendV1Response> {
            return localVarFp.ezsignfolderSendV1(pkiEzsignfolderID, ezsignfolderSendV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV2Request} ezsignfolderSendV2Request 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ezsignfolderSendV2(pkiEzsignfolderID: number, ezsignfolderSendV2Request: EzsignfolderSendV2Request, options?: any): AxiosPromise<EzsignfolderSendV2Response> {
            return localVarFp.ezsignfolderSendV2(pkiEzsignfolderID, ezsignfolderSendV2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send the Ezsignfolder to the signatories for signature
         * @param {number} pkiEzsignfolderID 
         * @param {EzsignfolderSendV3Request} ezsignfolderSendV3Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderSendV3(pkiEzsignfolderID: number, ezsignfolderSendV3Request: EzsignfolderSendV3Request, options?: any): AxiosPromise<EzsignfolderSendV3Response> {
            return localVarFp.ezsignfolderSendV3(pkiEzsignfolderID, ezsignfolderSendV3Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \"Non-completed\" Ezsigndocuments will be lost.
         * @summary Unsend the Ezsignfolder
         * @param {number} pkiEzsignfolderID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ezsignfolderUnsendV1(pkiEzsignfolderID: number, body: object, options?: any): AxiosPromise<EzsignfolderUnsendV1Response> {
            return localVarFp.ezsignfolderUnsendV1(pkiEzsignfolderID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectEzsignfolderApi - object-oriented interface
 * @export
 * @class ObjectEzsignfolderApi
 * @extends {BaseAPI}
 */
export class ObjectEzsignfolderApi extends BaseAPI {
    /**
     * 
     * @summary Archive the Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderArchiveV1(pkiEzsignfolderID: number, body: object, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderArchiveV1(pkiEzsignfolderID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download multiples files from an Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderBatchDownloadV1Request} ezsignfolderBatchDownloadV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderBatchDownloadV1(pkiEzsignfolderID: number, ezsignfolderBatchDownloadV1Request: EzsignfolderBatchDownloadV1Request, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderBatchDownloadV1(pkiEzsignfolderID, ezsignfolderBatchDownloadV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint allows to create one or many elements at once.  The array can contain simple (Just the object) or compound (The object and its child) objects.  Creating compound elements allows to reduce the multiple requests to create all child objects.
     * @summary Create a new Ezsignfolder
     * @param {Array<EzsignfolderCreateObjectV1Request>} ezsignfolderCreateObjectV1Request 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request: Array<EzsignfolderCreateObjectV1Request>, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderCreateObjectV1(ezsignfolderCreateObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint allows to create one or many elements at once.
     * @summary Create a new Ezsignfolder
     * @param {EzsignfolderCreateObjectV2Request} ezsignfolderCreateObjectV2Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request: EzsignfolderCreateObjectV2Request, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderCreateObjectV2(ezsignfolderCreateObjectV2Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderDeleteObjectV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderDeleteObjectV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dispose Ezsignfolders
     * @param {EzsignfolderDisposeEzsignfoldersV1Request} ezsignfolderDisposeEzsignfoldersV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request: EzsignfolderDisposeEzsignfoldersV1Request, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderDisposeEzsignfoldersV1(ezsignfolderDisposeEzsignfoldersV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dispose the Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderDisposeV1(pkiEzsignfolderID: number, body: object, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderDisposeV1(pkiEzsignfolderID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderEditObjectV1Request} ezsignfolderEditObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderEditObjectV1(pkiEzsignfolderID: number, ezsignfolderEditObjectV1Request: EzsignfolderEditObjectV1Request, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderEditObjectV1(pkiEzsignfolderID, ezsignfolderEditObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the Ezsignsignatures that can be signed and Ezsignformfieldgroups that can be filled by the current user at the current step in the process
     * @summary Retrieve actionable elements for the Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetActionableElementsV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetActionableElementsV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder\'s Ezsigndocuments
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetEzsigndocumentsV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder\'s Ezsignfoldersignerassociations
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetEzsignfoldersignerassociationsV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder\'s forms data
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetFormsDataV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetFormsDataV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eEzsignfolderStep | Unsent<br>Sent<br>PartiallySigned<br>Expired<br>Completed<br>Archived<br>Disposed| | eEzsignfoldertypePrivacylevel | User<br>Usergroup |
     * @summary Retrieve Ezsignfolder list
     * @param {'pkiEzsignfolderID_ASC' | 'pkiEzsignfolderID_DESC' | 'sEzsignfolderDescription_ASC' | 'sEzsignfolderDescription_DESC' | 'dtCreatedDate_ASC' | 'dtCreatedDate_DESC' | 'fkiEzsignfoldertypeID_ASC' | 'fkiEzsignfoldertypeID_DESC' | 'sEzsignfoldertypeNameX_ASC' | 'sEzsignfoldertypeNameX_DESC' | 'eEzsignfolderStep_ASC' | 'eEzsignfolderStep_DESC' | 'dtEzsignfolderSentdate_ASC' | 'dtEzsignfolderSentdate_DESC' | 'dtDueDate_ASC' | 'dtDueDate_DESC' | 'iTotalDocument_ASC' | 'iTotalDocument_DESC' | 'iTotalDocumentEdm_ASC' | 'iTotalDocumentEdm_DESC' | 'iTotalSignature_ASC' | 'iTotalSignature_DESC' | 'iTotalSignatureSigned_ASC' | 'iTotalSignatureSigned_DESC'} [eOrderBy] Specify how you want the results to be sorted
     * @param {number} [iRowMax] 
     * @param {number} [iRowOffset] 
     * @param {HeaderAcceptLanguage} [acceptLanguage] 
     * @param {string} [sFilter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetListV1(eOrderBy?: 'pkiEzsignfolderID_ASC' | 'pkiEzsignfolderID_DESC' | 'sEzsignfolderDescription_ASC' | 'sEzsignfolderDescription_DESC' | 'dtCreatedDate_ASC' | 'dtCreatedDate_DESC' | 'fkiEzsignfoldertypeID_ASC' | 'fkiEzsignfoldertypeID_DESC' | 'sEzsignfoldertypeNameX_ASC' | 'sEzsignfoldertypeNameX_DESC' | 'eEzsignfolderStep_ASC' | 'eEzsignfolderStep_DESC' | 'dtEzsignfolderSentdate_ASC' | 'dtEzsignfolderSentdate_DESC' | 'dtDueDate_ASC' | 'dtDueDate_DESC' | 'iTotalDocument_ASC' | 'iTotalDocument_DESC' | 'iTotalDocumentEdm_ASC' | 'iTotalDocumentEdm_DESC' | 'iTotalSignature_ASC' | 'iTotalSignature_DESC' | 'iTotalSignatureSigned_ASC' | 'iTotalSignatureSigned_DESC', iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetListV1(eOrderBy, iRowMax, iRowOffset, acceptLanguage, sFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetObjectV1(pkiEzsignfolderID: number, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetObjectV1(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderGetObjectV2(pkiEzsignfolderID: number, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderGetObjectV2(pkiEzsignfolderID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderImportEzsignfoldersignerassociationsV1Request} ezsignfolderImportEzsignfoldersignerassociationsV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID: number, ezsignfolderImportEzsignfoldersignerassociationsV1Request: EzsignfolderImportEzsignfoldersignerassociationsV1Request, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderImportEzsignfoldersignerassociationsV1(pkiEzsignfolderID, ezsignfolderImportEzsignfoldersignerassociationsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint imports all of the Ezsigntemplates from the Ezsigntemplatepackage into the Ezsignfolder as Ezsigndocuments.  This allows to automatically apply all the Ezsigntemplateformfieldgroups and Ezsigntemplatesignatures on the newly created Ezsigndocuments in a single step.
     * @summary Import an Ezsigntemplatepackage in the Ezsignfolder.
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderImportEzsigntemplatepackageV1Request} ezsignfolderImportEzsigntemplatepackageV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID: number, ezsignfolderImportEzsigntemplatepackageV1Request: EzsignfolderImportEzsigntemplatepackageV1Request, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderImportEzsigntemplatepackageV1(pkiEzsignfolderID, ezsignfolderImportEzsigntemplatepackageV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reorder Ezsigndocuments in the Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderReorderV1Request} ezsignfolderReorderV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderReorderV1(pkiEzsignfolderID: number, ezsignfolderReorderV1Request: EzsignfolderReorderV1Request, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderReorderV1(pkiEzsignfolderID, ezsignfolderReorderV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send the Ezsignfolder to the signatories for signature
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderSendV1Request} ezsignfolderSendV1Request 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderSendV1(pkiEzsignfolderID: number, ezsignfolderSendV1Request: EzsignfolderSendV1Request, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderSendV1(pkiEzsignfolderID, ezsignfolderSendV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send the Ezsignfolder to the signatories for signature
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderSendV2Request} ezsignfolderSendV2Request 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderSendV2(pkiEzsignfolderID: number, ezsignfolderSendV2Request: EzsignfolderSendV2Request, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderSendV2(pkiEzsignfolderID, ezsignfolderSendV2Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send the Ezsignfolder to the signatories for signature
     * @param {number} pkiEzsignfolderID 
     * @param {EzsignfolderSendV3Request} ezsignfolderSendV3Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderSendV3(pkiEzsignfolderID: number, ezsignfolderSendV3Request: EzsignfolderSendV3Request, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderSendV3(pkiEzsignfolderID, ezsignfolderSendV3Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Once an Ezsignfolder has been sent to signatories, it cannot be modified.  Using this endpoint, you can unsend the Ezsignfolder and make it modifiable again.  Signatories will receive an email informing them the signature process was aborted and they might receive a new invitation to sign.   Warning: Any signature previously made by signatories on \"Non-completed\" Ezsigndocuments will be lost.
     * @summary Unsend the Ezsignfolder
     * @param {number} pkiEzsignfolderID 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectEzsignfolderApi
     */
    public ezsignfolderUnsendV1(pkiEzsignfolderID: number, body: object, options?: AxiosRequestConfig) {
        return ObjectEzsignfolderApiFp(this.configuration).ezsignfolderUnsendV1(pkiEzsignfolderID, body, options).then((request) => request(this.axios, this.basePath));
    }
}
