/* tslint:disable */
/* eslint-disable */
/**
 * eZmax API Definition (Full)
 * This API expose all the functionnalities for the eZmax and eZsign applications.
 *
 * The version of the OpenAPI document: 1.2.1
 * Contact: support-api@ezmax.ca
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CommonResponse } from '../model';
// @ts-ignore
import type { CommonResponseError } from '../model';
// @ts-ignore
import type { HeaderAcceptLanguage } from '../model';
// @ts-ignore
import type { UserCreateObjectV1Request } from '../model';
// @ts-ignore
import type { UserCreateObjectV1Response } from '../model';
// @ts-ignore
import type { UserCreateObjectV2Request } from '../model';
// @ts-ignore
import type { UserCreateObjectV2Response } from '../model';
// @ts-ignore
import type { UserEditColleaguesV2Request } from '../model';
// @ts-ignore
import type { UserEditColleaguesV2Response } from '../model';
// @ts-ignore
import type { UserEditObjectV1Request } from '../model';
// @ts-ignore
import type { UserEditPermissionsV1Request } from '../model';
// @ts-ignore
import type { UserEditPermissionsV1Response } from '../model';
// @ts-ignore
import type { UserGetApikeysV1Response } from '../model';
// @ts-ignore
import type { UserGetAutocompleteV2Response } from '../model';
// @ts-ignore
import type { UserGetColleaguesV2Response } from '../model';
// @ts-ignore
import type { UserGetEffectivePermissionsV1Response } from '../model';
// @ts-ignore
import type { UserGetListV1Response } from '../model';
// @ts-ignore
import type { UserGetObjectV2Response } from '../model';
// @ts-ignore
import type { UserGetPermissionsV1Response } from '../model';
// @ts-ignore
import type { UserGetSubnetsV1Response } from '../model';
// @ts-ignore
import type { UserGetUsergroupexternalsV1Response } from '../model';
// @ts-ignore
import type { UserGetUsergroupsV1Response } from '../model';
// @ts-ignore
import { RequestSignature, IHeadersData } from '../api/request-signature';
/**
 * ObjectUserApi - axios parameter creator
 * @export
 */
export const ObjectUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new User
         * @param {UserCreateObjectV1Request} userCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateObjectV1: async (userCreateObjectV1Request: UserCreateObjectV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateObjectV1Request' is not null or undefined
            assertParamExists('userCreateObjectV1', 'userCreateObjectV1Request', userCreateObjectV1Request)
            const localVarPath = `/1/object/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateObjectV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new User
         * @param {UserCreateObjectV2Request} userCreateObjectV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateObjectV2: async (userCreateObjectV2Request: UserCreateObjectV2Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateObjectV2Request' is not null or undefined
            assertParamExists('userCreateObjectV2', 'userCreateObjectV2Request', userCreateObjectV2Request)
            const localVarPath = `/2/object/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateObjectV2Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Using this endpoint, you can edit multiple Colleagues at the same time.
         * @summary Edit multiple Colleagues
         * @param {number} pkiUserID 
         * @param {UserEditColleaguesV2Request} userEditColleaguesV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditColleaguesV2: async (pkiUserID: number, userEditColleaguesV2Request: UserEditColleaguesV2Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userEditColleaguesV2', 'pkiUserID', pkiUserID)
            // verify required parameter 'userEditColleaguesV2Request' is not null or undefined
            assertParamExists('userEditColleaguesV2', 'userEditColleaguesV2Request', userEditColleaguesV2Request)
            const localVarPath = `/2/object/user/{pkiUserID}/editColleagues`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userEditColleaguesV2Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'PUT' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit an existing User
         * @param {number} pkiUserID The unique ID of the User
         * @param {UserEditObjectV1Request} userEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditObjectV1: async (pkiUserID: number, userEditObjectV1Request: UserEditObjectV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userEditObjectV1', 'pkiUserID', pkiUserID)
            // verify required parameter 'userEditObjectV1Request' is not null or undefined
            assertParamExists('userEditObjectV1', 'userEditObjectV1Request', userEditObjectV1Request)
            const localVarPath = `/1/object/user/{pkiUserID}`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userEditObjectV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'PUT' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Using this endpoint, you can edit multiple Permissions at the same time.
         * @summary Edit multiple Permissions
         * @param {number} pkiUserID 
         * @param {UserEditPermissionsV1Request} userEditPermissionsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditPermissionsV1: async (pkiUserID: number, userEditPermissionsV1Request: UserEditPermissionsV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userEditPermissionsV1', 'pkiUserID', pkiUserID)
            // verify required parameter 'userEditPermissionsV1Request' is not null or undefined
            assertParamExists('userEditPermissionsV1', 'userEditPermissionsV1Request', userEditPermissionsV1Request)
            const localVarPath = `/1/object/user/{pkiUserID}/editPermissions`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userEditPermissionsV1Request, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'PUT' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Apikeys
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetApikeysV1: async (pkiUserID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userGetApikeysV1', 'pkiUserID', pkiUserID)
            const localVarPath = `/1/object/user/{pkiUserID}/getApikeys`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of User to be used in a dropdown or autocomplete control.
         * @summary Retrieve Users and IDs
         * @param {UserGetAutocompleteV2SSelectorEnum} sSelector The type of Users to return
         * @param {UserGetAutocompleteV2EFilterActiveEnum} [eFilterActive] Specify which results we want to display.
         * @param {string} [sQuery] Allow to filter the returned results
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetAutocompleteV2: async (sSelector: UserGetAutocompleteV2SSelectorEnum, eFilterActive?: UserGetAutocompleteV2EFilterActiveEnum, sQuery?: string, acceptLanguage?: HeaderAcceptLanguage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sSelector' is not null or undefined
            assertParamExists('userGetAutocompleteV2', 'sSelector', sSelector)
            const localVarPath = `/2/object/user/getAutocomplete/{sSelector}`
                .replace(`{${"sSelector"}}`, encodeURIComponent(String(sSelector)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (eFilterActive !== undefined) {
                localVarQueryParameter['eFilterActive'] = eFilterActive;
            }

            if (sQuery !== undefined) {
                localVarQueryParameter['sQuery'] = sQuery;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string'
                    ? acceptLanguage
                    : JSON.stringify(acceptLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Colleagues
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetColleaguesV2: async (pkiUserID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userGetColleaguesV2', 'pkiUserID', pkiUserID)
            const localVarPath = `/2/object/user/{pkiUserID}/getColleagues`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Effective Permissions refers to the combination of Permissions held by a User and the Permissions associated with the Usergroups they belong to.
         * @summary Retrieve an existing User\'s Effective Permissions
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetEffectivePermissionsV1: async (pkiUserID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userGetEffectivePermissionsV1', 'pkiUserID', pkiUserID)
            const localVarPath = `/1/object/user/{pkiUserID}/getEffectivePermissions`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eUserType | AgentBroker<br>Assistant<br>Employee<br>EzsignUser<br>Normal | | eUserOrigin | BuiltIn<br>External | | eUserEzsignaccess | No<br>PaidByOffice<br>PerDocument<br>Prepaid |
         * @summary Retrieve User list
         * @param {UserGetListV1EOrderByEnum} [eOrderBy] Specify how you want the results to be sorted
         * @param {number} [iRowMax] 
         * @param {number} [iRowOffset] 
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {string} [sFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetListV1: async (eOrderBy?: UserGetListV1EOrderByEnum, iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1/object/user/getList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (eOrderBy !== undefined) {
                localVarQueryParameter['eOrderBy'] = eOrderBy;
            }

            if (iRowMax !== undefined) {
                localVarQueryParameter['iRowMax'] = iRowMax;
            }

            if (iRowOffset !== undefined) {
                localVarQueryParameter['iRowOffset'] = iRowOffset;
            }

            if (sFilter !== undefined) {
                localVarQueryParameter['sFilter'] = sFilter;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = typeof acceptLanguage === 'string'
                    ? acceptLanguage
                    : JSON.stringify(acceptLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing User
         * @param {number} pkiUserID The unique ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetObjectV2: async (pkiUserID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userGetObjectV2', 'pkiUserID', pkiUserID)
            const localVarPath = `/2/object/user/{pkiUserID}`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Permissions
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetPermissionsV1: async (pkiUserID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userGetPermissionsV1', 'pkiUserID', pkiUserID)
            const localVarPath = `/1/object/user/{pkiUserID}/getPermissions`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Subnets
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetSubnetsV1: async (pkiUserID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userGetSubnetsV1', 'pkiUserID', pkiUserID)
            const localVarPath = `/1/object/user/{pkiUserID}/getSubnets`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User\'s Usergroupexternals
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetUsergroupexternalsV1: async (pkiUserID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userGetUsergroupexternalsV1', 'pkiUserID', pkiUserID)
            const localVarPath = `/1/object/user/{pkiUserID}/getUsergroupexternals`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User\'s Usergroups
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetUsergroupsV1: async (pkiUserID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userGetUsergroupsV1', 'pkiUserID', pkiUserID)
            const localVarPath = `/1/object/user/{pkiUserID}/getUsergroups`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'GET' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send the password reset email
         * @summary Send password reset
         * @param {number} pkiUserID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSendPasswordResetV1: async (pkiUserID: number, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkiUserID' is not null or undefined
            assertParamExists('userSendPasswordResetV1', 'pkiUserID', pkiUserID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userSendPasswordResetV1', 'body', body)
            const localVarPath = `/1/object/user/{pkiUserID}/sendPasswordReset`
                .replace(`{${"pkiUserID"}}`, encodeURIComponent(String(pkiUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            let basePath = DUMMY_BASE_URL
            if (configuration && configuration.basePath) basePath = configuration.basePath
            //const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const localVarUrlObj = new URL(localVarPath, basePath);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            //localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.headers = {...headersFromBaseOptions, ...localVarHeaderParameter,  ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            // Signature
            if (configuration && configuration.apiKey) {
                const secret = configuration.getSecret()
                if (secret) {
                    const headers:IHeadersData = {
                        authorization: configuration.apiKey as string,
                        secret: secret as string,
                        method: 'POST' as string,
                        url: basePath + toPathString(localVarUrlObj) as string,
                        body: localVarRequestOptions.data || '' as string
                    }
                    const signatureHeaders = RequestSignature.getHeaders(headers)
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, ...signatureHeaders }
                } 
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectUserApi - functional programming interface
 * @export
 */
export const ObjectUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObjectUserApiAxiosParamCreator(configuration)
    return {
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new User
         * @param {UserCreateObjectV1Request} userCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateObjectV1(userCreateObjectV1Request: UserCreateObjectV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCreateObjectV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateObjectV1(userCreateObjectV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userCreateObjectV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new User
         * @param {UserCreateObjectV2Request} userCreateObjectV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateObjectV2(userCreateObjectV2Request: UserCreateObjectV2Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCreateObjectV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateObjectV2(userCreateObjectV2Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userCreateObjectV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Using this endpoint, you can edit multiple Colleagues at the same time.
         * @summary Edit multiple Colleagues
         * @param {number} pkiUserID 
         * @param {UserEditColleaguesV2Request} userEditColleaguesV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEditColleaguesV2(pkiUserID: number, userEditColleaguesV2Request: UserEditColleaguesV2Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEditColleaguesV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userEditColleaguesV2(pkiUserID, userEditColleaguesV2Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userEditColleaguesV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit an existing User
         * @param {number} pkiUserID The unique ID of the User
         * @param {UserEditObjectV1Request} userEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEditObjectV1(pkiUserID: number, userEditObjectV1Request: UserEditObjectV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userEditObjectV1(pkiUserID, userEditObjectV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userEditObjectV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Using this endpoint, you can edit multiple Permissions at the same time.
         * @summary Edit multiple Permissions
         * @param {number} pkiUserID 
         * @param {UserEditPermissionsV1Request} userEditPermissionsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEditPermissionsV1(pkiUserID: number, userEditPermissionsV1Request: UserEditPermissionsV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEditPermissionsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userEditPermissionsV1(pkiUserID, userEditPermissionsV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userEditPermissionsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Apikeys
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetApikeysV1(pkiUserID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetApikeysV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetApikeysV1(pkiUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userGetApikeysV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the list of User to be used in a dropdown or autocomplete control.
         * @summary Retrieve Users and IDs
         * @param {UserGetAutocompleteV2SSelectorEnum} sSelector The type of Users to return
         * @param {UserGetAutocompleteV2EFilterActiveEnum} [eFilterActive] Specify which results we want to display.
         * @param {string} [sQuery] Allow to filter the returned results
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetAutocompleteV2(sSelector: UserGetAutocompleteV2SSelectorEnum, eFilterActive?: UserGetAutocompleteV2EFilterActiveEnum, sQuery?: string, acceptLanguage?: HeaderAcceptLanguage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetAutocompleteV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetAutocompleteV2(sSelector, eFilterActive, sQuery, acceptLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userGetAutocompleteV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Colleagues
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetColleaguesV2(pkiUserID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetColleaguesV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetColleaguesV2(pkiUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userGetColleaguesV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Effective Permissions refers to the combination of Permissions held by a User and the Permissions associated with the Usergroups they belong to.
         * @summary Retrieve an existing User\'s Effective Permissions
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetEffectivePermissionsV1(pkiUserID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetEffectivePermissionsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetEffectivePermissionsV1(pkiUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userGetEffectivePermissionsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eUserType | AgentBroker<br>Assistant<br>Employee<br>EzsignUser<br>Normal | | eUserOrigin | BuiltIn<br>External | | eUserEzsignaccess | No<br>PaidByOffice<br>PerDocument<br>Prepaid |
         * @summary Retrieve User list
         * @param {UserGetListV1EOrderByEnum} [eOrderBy] Specify how you want the results to be sorted
         * @param {number} [iRowMax] 
         * @param {number} [iRowOffset] 
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {string} [sFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetListV1(eOrderBy?: UserGetListV1EOrderByEnum, iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetListV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetListV1(eOrderBy, iRowMax, iRowOffset, acceptLanguage, sFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userGetListV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing User
         * @param {number} pkiUserID The unique ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetObjectV2(pkiUserID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetObjectV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetObjectV2(pkiUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userGetObjectV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Permissions
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetPermissionsV1(pkiUserID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetPermissionsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetPermissionsV1(pkiUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userGetPermissionsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Subnets
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetSubnetsV1(pkiUserID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetSubnetsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetSubnetsV1(pkiUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userGetSubnetsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get User\'s Usergroupexternals
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetUsergroupexternalsV1(pkiUserID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetUsergroupexternalsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetUsergroupexternalsV1(pkiUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userGetUsergroupexternalsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get User\'s Usergroups
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetUsergroupsV1(pkiUserID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetUsergroupsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetUsergroupsV1(pkiUserID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userGetUsergroupsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send the password reset email
         * @summary Send password reset
         * @param {number} pkiUserID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSendPasswordResetV1(pkiUserID: number, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSendPasswordResetV1(pkiUserID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectUserApi.userSendPasswordResetV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ObjectUserApi - factory interface
 * @export
 */
export const ObjectUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObjectUserApiFp(configuration)
    return {
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new User
         * @param {UserCreateObjectV1Request} userCreateObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateObjectV1(userCreateObjectV1Request: UserCreateObjectV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UserCreateObjectV1Response> {
            return localVarFp.userCreateObjectV1(userCreateObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint allows to create one or many elements at once.
         * @summary Create a new User
         * @param {UserCreateObjectV2Request} userCreateObjectV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateObjectV2(userCreateObjectV2Request: UserCreateObjectV2Request, options?: RawAxiosRequestConfig): AxiosPromise<UserCreateObjectV2Response> {
            return localVarFp.userCreateObjectV2(userCreateObjectV2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Using this endpoint, you can edit multiple Colleagues at the same time.
         * @summary Edit multiple Colleagues
         * @param {number} pkiUserID 
         * @param {UserEditColleaguesV2Request} userEditColleaguesV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditColleaguesV2(pkiUserID: number, userEditColleaguesV2Request: UserEditColleaguesV2Request, options?: RawAxiosRequestConfig): AxiosPromise<UserEditColleaguesV2Response> {
            return localVarFp.userEditColleaguesV2(pkiUserID, userEditColleaguesV2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit an existing User
         * @param {number} pkiUserID The unique ID of the User
         * @param {UserEditObjectV1Request} userEditObjectV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditObjectV1(pkiUserID: number, userEditObjectV1Request: UserEditObjectV1Request, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.userEditObjectV1(pkiUserID, userEditObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Using this endpoint, you can edit multiple Permissions at the same time.
         * @summary Edit multiple Permissions
         * @param {number} pkiUserID 
         * @param {UserEditPermissionsV1Request} userEditPermissionsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditPermissionsV1(pkiUserID: number, userEditPermissionsV1Request: UserEditPermissionsV1Request, options?: RawAxiosRequestConfig): AxiosPromise<UserEditPermissionsV1Response> {
            return localVarFp.userEditPermissionsV1(pkiUserID, userEditPermissionsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Apikeys
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetApikeysV1(pkiUserID: number, options?: RawAxiosRequestConfig): AxiosPromise<UserGetApikeysV1Response> {
            return localVarFp.userGetApikeysV1(pkiUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of User to be used in a dropdown or autocomplete control.
         * @summary Retrieve Users and IDs
         * @param {UserGetAutocompleteV2SSelectorEnum} sSelector The type of Users to return
         * @param {UserGetAutocompleteV2EFilterActiveEnum} [eFilterActive] Specify which results we want to display.
         * @param {string} [sQuery] Allow to filter the returned results
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetAutocompleteV2(sSelector: UserGetAutocompleteV2SSelectorEnum, eFilterActive?: UserGetAutocompleteV2EFilterActiveEnum, sQuery?: string, acceptLanguage?: HeaderAcceptLanguage, options?: RawAxiosRequestConfig): AxiosPromise<UserGetAutocompleteV2Response> {
            return localVarFp.userGetAutocompleteV2(sSelector, eFilterActive, sQuery, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Colleagues
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetColleaguesV2(pkiUserID: number, options?: RawAxiosRequestConfig): AxiosPromise<UserGetColleaguesV2Response> {
            return localVarFp.userGetColleaguesV2(pkiUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Effective Permissions refers to the combination of Permissions held by a User and the Permissions associated with the Usergroups they belong to.
         * @summary Retrieve an existing User\'s Effective Permissions
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetEffectivePermissionsV1(pkiUserID: number, options?: RawAxiosRequestConfig): AxiosPromise<UserGetEffectivePermissionsV1Response> {
            return localVarFp.userGetEffectivePermissionsV1(pkiUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eUserType | AgentBroker<br>Assistant<br>Employee<br>EzsignUser<br>Normal | | eUserOrigin | BuiltIn<br>External | | eUserEzsignaccess | No<br>PaidByOffice<br>PerDocument<br>Prepaid |
         * @summary Retrieve User list
         * @param {UserGetListV1EOrderByEnum} [eOrderBy] Specify how you want the results to be sorted
         * @param {number} [iRowMax] 
         * @param {number} [iRowOffset] 
         * @param {HeaderAcceptLanguage} [acceptLanguage] 
         * @param {string} [sFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetListV1(eOrderBy?: UserGetListV1EOrderByEnum, iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserGetListV1Response> {
            return localVarFp.userGetListV1(eOrderBy, iRowMax, iRowOffset, acceptLanguage, sFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing User
         * @param {number} pkiUserID The unique ID of the User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetObjectV2(pkiUserID: number, options?: RawAxiosRequestConfig): AxiosPromise<UserGetObjectV2Response> {
            return localVarFp.userGetObjectV2(pkiUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Permissions
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetPermissionsV1(pkiUserID: number, options?: RawAxiosRequestConfig): AxiosPromise<UserGetPermissionsV1Response> {
            return localVarFp.userGetPermissionsV1(pkiUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing User\'s Subnets
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetSubnetsV1(pkiUserID: number, options?: RawAxiosRequestConfig): AxiosPromise<UserGetSubnetsV1Response> {
            return localVarFp.userGetSubnetsV1(pkiUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User\'s Usergroupexternals
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetUsergroupexternalsV1(pkiUserID: number, options?: RawAxiosRequestConfig): AxiosPromise<UserGetUsergroupexternalsV1Response> {
            return localVarFp.userGetUsergroupexternalsV1(pkiUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User\'s Usergroups
         * @param {number} pkiUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetUsergroupsV1(pkiUserID: number, options?: RawAxiosRequestConfig): AxiosPromise<UserGetUsergroupsV1Response> {
            return localVarFp.userGetUsergroupsV1(pkiUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Send the password reset email
         * @summary Send password reset
         * @param {number} pkiUserID 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSendPasswordResetV1(pkiUserID: number, body: object, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponse> {
            return localVarFp.userSendPasswordResetV1(pkiUserID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectUserApi - object-oriented interface
 * @export
 * @class ObjectUserApi
 * @extends {BaseAPI}
 */
export class ObjectUserApi extends BaseAPI {
    /**
     * The endpoint allows to create one or many elements at once.
     * @summary Create a new User
     * @param {UserCreateObjectV1Request} userCreateObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userCreateObjectV1(userCreateObjectV1Request: UserCreateObjectV1Request, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userCreateObjectV1(userCreateObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint allows to create one or many elements at once.
     * @summary Create a new User
     * @param {UserCreateObjectV2Request} userCreateObjectV2Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userCreateObjectV2(userCreateObjectV2Request: UserCreateObjectV2Request, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userCreateObjectV2(userCreateObjectV2Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Using this endpoint, you can edit multiple Colleagues at the same time.
     * @summary Edit multiple Colleagues
     * @param {number} pkiUserID 
     * @param {UserEditColleaguesV2Request} userEditColleaguesV2Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userEditColleaguesV2(pkiUserID: number, userEditColleaguesV2Request: UserEditColleaguesV2Request, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userEditColleaguesV2(pkiUserID, userEditColleaguesV2Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit an existing User
     * @param {number} pkiUserID The unique ID of the User
     * @param {UserEditObjectV1Request} userEditObjectV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userEditObjectV1(pkiUserID: number, userEditObjectV1Request: UserEditObjectV1Request, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userEditObjectV1(pkiUserID, userEditObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Using this endpoint, you can edit multiple Permissions at the same time.
     * @summary Edit multiple Permissions
     * @param {number} pkiUserID 
     * @param {UserEditPermissionsV1Request} userEditPermissionsV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userEditPermissionsV1(pkiUserID: number, userEditPermissionsV1Request: UserEditPermissionsV1Request, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userEditPermissionsV1(pkiUserID, userEditPermissionsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing User\'s Apikeys
     * @param {number} pkiUserID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userGetApikeysV1(pkiUserID: number, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userGetApikeysV1(pkiUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of User to be used in a dropdown or autocomplete control.
     * @summary Retrieve Users and IDs
     * @param {UserGetAutocompleteV2SSelectorEnum} sSelector The type of Users to return
     * @param {UserGetAutocompleteV2EFilterActiveEnum} [eFilterActive] Specify which results we want to display.
     * @param {string} [sQuery] Allow to filter the returned results
     * @param {HeaderAcceptLanguage} [acceptLanguage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userGetAutocompleteV2(sSelector: UserGetAutocompleteV2SSelectorEnum, eFilterActive?: UserGetAutocompleteV2EFilterActiveEnum, sQuery?: string, acceptLanguage?: HeaderAcceptLanguage, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userGetAutocompleteV2(sSelector, eFilterActive, sQuery, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing User\'s Colleagues
     * @param {number} pkiUserID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userGetColleaguesV2(pkiUserID: number, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userGetColleaguesV2(pkiUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Effective Permissions refers to the combination of Permissions held by a User and the Permissions associated with the Usergroups they belong to.
     * @summary Retrieve an existing User\'s Effective Permissions
     * @param {number} pkiUserID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userGetEffectivePermissionsV1(pkiUserID: number, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userGetEffectivePermissionsV1(pkiUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enum values that can be filtered in query parameter *sFilter*:  | Variable | Valid values | |---|---| | eUserType | AgentBroker<br>Assistant<br>Employee<br>EzsignUser<br>Normal | | eUserOrigin | BuiltIn<br>External | | eUserEzsignaccess | No<br>PaidByOffice<br>PerDocument<br>Prepaid |
     * @summary Retrieve User list
     * @param {UserGetListV1EOrderByEnum} [eOrderBy] Specify how you want the results to be sorted
     * @param {number} [iRowMax] 
     * @param {number} [iRowOffset] 
     * @param {HeaderAcceptLanguage} [acceptLanguage] 
     * @param {string} [sFilter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userGetListV1(eOrderBy?: UserGetListV1EOrderByEnum, iRowMax?: number, iRowOffset?: number, acceptLanguage?: HeaderAcceptLanguage, sFilter?: string, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userGetListV1(eOrderBy, iRowMax, iRowOffset, acceptLanguage, sFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing User
     * @param {number} pkiUserID The unique ID of the User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userGetObjectV2(pkiUserID: number, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userGetObjectV2(pkiUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing User\'s Permissions
     * @param {number} pkiUserID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userGetPermissionsV1(pkiUserID: number, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userGetPermissionsV1(pkiUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing User\'s Subnets
     * @param {number} pkiUserID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userGetSubnetsV1(pkiUserID: number, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userGetSubnetsV1(pkiUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User\'s Usergroupexternals
     * @param {number} pkiUserID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userGetUsergroupexternalsV1(pkiUserID: number, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userGetUsergroupexternalsV1(pkiUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User\'s Usergroups
     * @param {number} pkiUserID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userGetUsergroupsV1(pkiUserID: number, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userGetUsergroupsV1(pkiUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send the password reset email
     * @summary Send password reset
     * @param {number} pkiUserID 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUserApi
     */
    public userSendPasswordResetV1(pkiUserID: number, body: object, options?: RawAxiosRequestConfig) {
        return ObjectUserApiFp(this.configuration).userSendPasswordResetV1(pkiUserID, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UserGetAutocompleteV2SSelectorEnum = {
    AgentBrokerAssistant: 'AgentBrokerAssistant',
    AgentBrokerEmployeeEzsignUserNormal: 'AgentBrokerEmployeeEzsignUserNormal',
    AgentBrokerEmployeeNormalBuiltIn: 'AgentBrokerEmployeeNormalBuiltIn',
    AgentBrokerEzsignuserNormal: 'AgentBrokerEzsignuserNormal',
    ClonableUsers: 'ClonableUsers',
    EzsignuserBuiltIn: 'EzsignuserBuiltIn',
    Ezsignuser: 'Ezsignuser',
    Normal: 'Normal',
    UsergroupDelegated: 'UsergroupDelegated'
} as const;
export type UserGetAutocompleteV2SSelectorEnum = typeof UserGetAutocompleteV2SSelectorEnum[keyof typeof UserGetAutocompleteV2SSelectorEnum];
/**
 * @export
 */
export const UserGetAutocompleteV2EFilterActiveEnum = {
    All: 'All',
    Active: 'Active',
    Inactive: 'Inactive'
} as const;
export type UserGetAutocompleteV2EFilterActiveEnum = typeof UserGetAutocompleteV2EFilterActiveEnum[keyof typeof UserGetAutocompleteV2EFilterActiveEnum];
/**
 * @export
 */
export const UserGetListV1EOrderByEnum = {
    pkiUserID_ASC: 'pkiUserID_ASC',
    pkiUserID_DESC: 'pkiUserID_DESC',
    sUserFirstname_ASC: 'sUserFirstname_ASC',
    sUserFirstname_DESC: 'sUserFirstname_DESC',
    sUserLastname_ASC: 'sUserLastname_ASC',
    sUserLastname_DESC: 'sUserLastname_DESC',
    sUserLoginname_ASC: 'sUserLoginname_ASC',
    sUserLoginname_DESC: 'sUserLoginname_DESC',
    bUserIsactive_ASC: 'bUserIsactive_ASC',
    bUserIsactive_DESC: 'bUserIsactive_DESC',
    eUserType_ASC: 'eUserType_ASC',
    eUserType_DESC: 'eUserType_DESC',
    eUserOrigin_ASC: 'eUserOrigin_ASC',
    eUserOrigin_DESC: 'eUserOrigin_DESC',
    eUserEzsignaccess_ASC: 'eUserEzsignaccess_ASC',
    eUserEzsignaccess_DESC: 'eUserEzsignaccess_DESC',
    dtUserEzsignprepaidexpiration_ASC: 'dtUserEzsignprepaidexpiration_ASC',
    dtUserEzsignprepaidexpiration_DESC: 'dtUserEzsignprepaidexpiration_DESC',
    sEmailAddress_ASC: 'sEmailAddress_ASC',
    sEmailAddress_DESC: 'sEmailAddress_DESC'
} as const;
export type UserGetListV1EOrderByEnum = typeof UserGetListV1EOrderByEnum[keyof typeof UserGetListV1EOrderByEnum];
